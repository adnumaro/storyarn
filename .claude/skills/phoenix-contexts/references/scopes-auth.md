# Scopes and Authorization Reference

## Version Compatibility

| Phoenix Version | Pattern                                                          |
|-----------------|------------------------------------------------------------------|
| 1.8+            | Built-in `%Scope{}` struct (documented below)                    |
| 1.7 and earlier | Manual authorization context (see "Pre-Scopes Patterns" section) |

**Detection**: Check `{:phoenix, "~> 1.X"}` in mix.exs to determine version.

---

## Phoenix 1.8+ Scopes

Scopes provide **secure data access by default**, addressing OWASP's
"Broken access control". Generated by `mix phx.gen.auth`.

```elixir
defmodule MyApp.Accounts.Scope do
  defstruct user: nil

  def for_user(%User{} = user), do: %__MODULE__{user: user}
  def for_user(nil), do: nil
end
```

### Scope Configuration

Scopes are configured in `config/config.exs`:

```elixir
config :my_app, :scopes,
  user: [
    default: true,
    module: MyApp.Accounts.Scope,
    assign_key: :current_scope,
    access_path: [:user, :id],
    schema_key: :user_id,
    schema_type: :id,
    schema_table: :users,
    test_data_fixture: MyApp.AccountsFixtures,
    test_setup_helper: :register_and_log_in_user
  ]
```

| Option         | Purpose                                    |
|----------------|--------------------------------------------|
| `default`      | Boolean, only one scope can be default     |
| `module`       | Module defining scope struct               |
| `assign_key`   | Key for socket/conn assigns                |
| `access_path`  | Path to identifying field (`[:user, :id]`) |
| `schema_key`   | Foreign key tying resources to scope       |
| `schema_type`  | FK field type (`:id` or `:binary_id`)      |
| `route_prefix` | Nested route template (multi-tenant)       |

### Generator Integration

With default scope configured, generators automatically:

- Pass scope as first arg to context functions
- Filter DB queries by scope
- Subscribe to scoped PubSub in LiveViews

### Multi-Tenant Scope Augmentation

Extend scope for organizations:

```elixir
defmodule MyApp.Accounts.Scope do
  defstruct user: nil, organization: nil

  def for_user(%User{} = user), do: %__MODULE__{user: user}

  def put_organization(%__MODULE__{} = scope, %Organization{} = org) do
    %{scope | organization: org}
  end
end
```

Router plug for augmentation:

```elixir
def assign_org_to_scope(conn, _opts) do
  scope = conn.assigns.current_scope
  if slug = conn.params["org"] do
    org = Accounts.get_organization_by_slug!(scope, slug)
    assign(conn, :current_scope, Scope.put_organization(scope, org))
  else
    conn
  end
end
```

LiveView hook for augmentation:

```elixir
def on_mount(:assign_org, %{"org" => slug}, _session, socket) do
  case socket.assigns.current_scope do
    %{organization: nil} = scope ->
      org = Accounts.get_organization_by_slug!(scope, slug)
      {:cont, assign(socket, :current_scope,
        Scope.put_organization(scope, org))}
    _ ->
      {:cont, socket}
  end
end

def on_mount(:assign_org, _params, _session, socket) do
  {:cont, socket}
end
```

Multi-scope config for orgs:

```elixir
config :my_app, :scopes,
  user: [default: true, ...],
  organization: [
    module: MyApp.Accounts.Scope,
    assign_key: :current_scope,
    access_path: [:organization, :id],
    route_prefix: "/organizations/:org",
    route_access_path: [:organization, :slug],
    schema_key: :org_id,
    schema_type: :id,
    schema_table: :organizations,
    test_data_fixture: MyApp.AccountsFixtures,
    test_setup_helper: :register_and_log_in_user_with_org
  ]
```

### Scope Helpers for IEx

```elixir
def for(opts) when is_list(opts) do
  cond do
    opts[:user] && opts[:org] ->
      opts[:user] |> user() |> for_user()
      |> put_organization(org(opts[:org]))
    opts[:user] ->
      opts[:user] |> user() |> for_user()
  end
end

# Usage: MyApp.Blog.list_posts(Scope.for(user: 1, org: "foo"))
```

## Plug Patterns

### Authentication Plug

```elixir
defp fetch_current_user(conn, _opts) do
  case get_session(conn, :user_token) do
    nil -> assign(conn, :current_user, nil)
    token -> assign(conn, :current_user, Accounts.get_user_by_session_token(token))
  end
end

defp require_authenticated_user(conn, _opts) do
  if conn.assigns[:current_user] do
    conn
  else
    conn
    |> put_flash(:error, "You must log in to access this page.")
    |> redirect(to: ~p"/login")
    |> halt()
  end
end
```

### Authorization Plug (action-specific)

```elixir
plug :authorize_resource when action in [:edit, :update, :delete]

defp authorize_resource(conn, _opts) do
  if Authorizer.can_access?(conn.assigns.current_user, conn.assigns.resource) do
    conn
  else
    conn
    |> put_flash(:error, "Unauthorized")
    |> redirect(to: ~p"/")
    |> halt()
  end
end
```

### Fetch Resource Plug

```elixir
plug :fetch_message when action in [:show, :edit, :update, :delete]

defp fetch_message(conn, _opts) do
  message = Blog.get_message!(conn.assigns.current_scope, conn.params["id"])
  assign(conn, :message, message)
end
```

### API Authentication

```elixir
def fetch_current_scope_for_api_user(conn, _opts) do
  with ["Bearer " <> token] <- get_req_header(conn, "authorization"),
       {:ok, user} <- Accounts.fetch_user_by_api_token(token) do
    assign(conn, :current_scope, Scope.for_user(user))
  else
    _ ->
      conn
      |> send_resp(:unauthorized, "Invalid or missing token")
      |> halt()
  end
end
```

---

## Pre-Scopes Patterns (Phoenix 1.7 and earlier)

For Phoenix 1.7 projects, implement authorization context manually.

### Authority Struct Pattern

```elixir
# lib/my_app/accounts/authority.ex
defmodule MyApp.Accounts.Authority do
  @moduledoc """
  Authorization context for scoping operations.
  Equivalent to Phoenix 1.8+ Scope but manually implemented.
  """

  defstruct [:user, :tenant_id, :permissions]

  @type t :: %__MODULE__{
    user: MyApp.Accounts.User.t() | nil,
    tenant_id: integer() | nil,
    permissions: [atom()]
  }

  def new(user, opts \\ []) do
    %__MODULE__{
      user: user,
      tenant_id: Keyword.get(opts, :tenant_id) || user && user.tenant_id,
      permissions: Keyword.get(opts, :permissions, [])
    }
  end

  def guest, do: %__MODULE__{}
end
```

### Using Authority in Contexts

```elixir
defmodule MyApp.Posts do
  alias MyApp.Accounts.Authority

  @doc """
  Lists posts scoped to the authority's tenant.
  """
  def list_posts(%Authority{tenant_id: tenant_id}) when not is_nil(tenant_id) do
    Post
    |> where(tenant_id: ^tenant_id)
    |> Repo.all()
  end

  def list_posts(%Authority{tenant_id: nil}) do
    {:error, :unauthorized}
  end

  @doc """
  Creates a post with author from authority.
  """
  def create_post(%Authority{user: user, tenant_id: tenant_id}, attrs)
      when not is_nil(user) do
    %Post{author_id: user.id, tenant_id: tenant_id}
    |> Post.changeset(attrs)
    |> Repo.insert()
  end
end
```

### Plug for Building Authority

```elixir
defmodule MyAppWeb.Plugs.BuildAuthority do
  import Plug.Conn
  alias MyApp.Accounts.Authority

  def init(opts), do: opts

  def call(conn, _opts) do
    authority = case conn.assigns[:current_user] do
      nil -> Authority.guest()
      user -> Authority.new(user)
    end

    assign(conn, :authority, authority)
  end
end
```

### In Controllers

```elixir
defmodule MyAppWeb.PostController do
  use MyAppWeb, :controller

  def index(conn, _params) do
    case Posts.list_posts(conn.assigns.authority) do
      {:error, :unauthorized} ->
        conn |> put_status(:forbidden) |> json(%{error: "Unauthorized"})

      posts ->
        render(conn, :index, posts: posts)
    end
  end
end
```

### Migration Path to 1.8

When upgrading to Phoenix 1.8:

1. Replace `Authority` struct with `%Scope{}`
2. Update context function signatures to accept `%Scope{}`
3. Replace `BuildAuthority` plug with generated auth assigns
4. Phoenix 1.8 generators create Scope-aware code automatically
