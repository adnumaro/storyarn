defmodule Storyarn.Exports.Serializers.GodotDialogic do
  @moduledoc """
  Godot Dialogic 2 serializer.

  Produces `.dtl` timeline files for Dialogic 2, the dominant dialogue addon
  for the Godot engine (~5.2k stars). Each flow becomes one `.dtl` file.

  ## Output

  Returns `{:ok, [{filename, content}, ...]}` with:
  - `.dtl` file(s) — one per flow
  - `metadata.json` — character/variable/timeline mapping
  """

  @behaviour Storyarn.Exports.Serializer

  alias Storyarn.Exports.{ExportOptions, ExpressionTranspiler}
  alias Storyarn.Exports.Serializers.{GraphTraversal, Helpers}

  @impl true
  def content_type, do: "text/plain"

  @impl true
  def file_extension, do: "dtl"

  @impl true
  def format_label, do: "Godot Dialogic (.dtl)"

  @impl true
  def supported_sections, do: [:flows, :sheets]

  @impl true
  def serialize(project_data, %ExportOptions{} = _opts) do
    sheets = project_data.sheets || []
    flows = project_data.flows || []
    variables = Helpers.collect_variables(sheets)
    speaker_map = Helpers.build_speaker_map(sheets)

    dtl_files =
      Enum.map(flows, fn flow ->
        filename = flow_filename(flow)
        content = flow_to_dtl(flow, speaker_map)
        {filename, content}
      end)

    metadata = build_metadata(project_data.project, sheets, variables, flows)

    {:ok, dtl_files ++ [{"metadata.json", Jason.encode!(metadata, pretty: true)}]}
  end

  @impl true
  def serialize_to_file(_data, _file_path, _options, _callbacks) do
    {:error, :not_implemented}
  end

  # ---------------------------------------------------------------------------
  # Flow → .dtl
  # ---------------------------------------------------------------------------

  defp flow_to_dtl(flow, speaker_map) do
    {instructions, hub_sections} = GraphTraversal.linearize(flow)

    header = "# Generated by Storyarn — Dialogic 2 timeline"
    body = render_instructions(instructions, speaker_map, 0)

    hub_blocks =
      Enum.flat_map(hub_sections, fn {label, instrs} ->
        ["", "label #{label}"] ++ render_instructions(instrs, speaker_map, 0)
      end)

    lines = [header, ""] ++ body ++ hub_blocks
    Enum.join(lines, "\n") <> "\n"
  end

  defp flow_filename(flow) do
    name = Helpers.shortcut_to_identifier(flow.shortcut || flow.name || "flow_#{flow.id}")
    "#{name}.dtl"
  end

  # ---------------------------------------------------------------------------
  # Instruction rendering
  # ---------------------------------------------------------------------------

  defp render_instructions(instructions, speaker_map, depth) do
    Enum.flat_map(instructions, &render_instruction(&1, speaker_map, depth))
  end

  defp render_instruction({:dialogue, node}, speaker_map, depth) do
    data = node.data || %{}
    text = data |> Helpers.dialogue_text() |> escape_dtl_text()
    speaker = Helpers.speaker_name(data, speaker_map)
    stage_dirs = Helpers.strip_html(data["stage_directions"] || "")

    dialogue_line =
      if speaker do
        "#{indent(depth)}#{speaker}: #{text}"
      else
        "#{indent(depth)}#{text}"
      end

    stage_line =
      if stage_dirs != "" do
        ["#{indent(depth)}# [Stage: #{stage_dirs}]"]
      else
        []
      end

    [dialogue_line] ++ stage_line
  end

  defp render_instruction({:choices_start, _node}, _speaker_map, _depth), do: []

  defp render_instruction({:choice, resp, _idx}, _speaker_map, depth) do
    text =
      (resp["text"] || resp["menu_text"] || "")
      |> Helpers.strip_html()
      |> escape_dtl_text()

    condition = build_dtl_condition(resp["condition"])

    choice_line =
      if condition do
        "#{indent(depth)}- #{text} [if #{condition}]"
      else
        "#{indent(depth)}- #{text}"
      end

    assign_lines =
      case resp["instruction_assignments"] do
        [_ | _] = assignments ->
          case ExpressionTranspiler.transpile_instruction(assignments, :godot) do
            {:ok, expr, _} when expr != "" ->
              expr |> String.split("\n") |> Enum.map(&"#{indent(depth + 1)}#{&1}")

            _ ->
              []
          end

        _ ->
          []
      end

    [choice_line | assign_lines]
  end

  defp render_instruction({:choices_end, _node}, _speaker_map, _depth), do: []

  defp render_instruction({:condition_start, node}, _speaker_map, depth) do
    data = node.data || %{}
    condition = Helpers.extract_condition(data["condition"])

    case ExpressionTranspiler.transpile_condition(condition, :godot) do
      {:ok, expr, _} when expr != "" ->
        ["#{indent(depth)}if #{expr}:"]

      _ ->
        ["#{indent(depth)}if true:"]
    end
  end

  defp render_instruction({:condition_branch, _pin, _label, idx}, _sm, depth) do
    case idx do
      0 -> []
      1 -> ["#{indent(depth)}else:"]
      n -> ["#{indent(depth)}# (branch #{n})"]
    end
  end

  # Dialogic uses de-indentation to end blocks — no explicit end marker
  defp render_instruction({:condition_end, _node}, _speaker_map, _depth), do: []

  defp render_instruction({:instruction, node}, _speaker_map, depth) do
    data = node.data || %{}
    assignments = Helpers.extract_assignments(data)

    case ExpressionTranspiler.transpile_instruction(assignments, :godot) do
      {:ok, expr, _} when expr != "" ->
        expr |> String.split("\n") |> Enum.map(&"#{indent(depth)}#{&1}")

      _ ->
        []
    end
  end

  defp render_instruction({:scene, node}, _speaker_map, depth) do
    data = node.data || %{}
    location = data["location"] || data["slug_line"] || ""
    ["#{indent(depth)}# location: #{location}"]
  end

  defp render_instruction({:subflow, node}, _speaker_map, depth) do
    data = node.data || %{}
    target = Helpers.shortcut_to_identifier(data["flow_shortcut"] || "subflow_#{node.id}")
    ["#{indent(depth)}jump #{target}/"]
  end

  defp render_instruction({:jump, _node, target_label}, _speaker_map, depth) do
    ["#{indent(depth)}jump #{target_label}"]
  end

  defp render_instruction({:divert, target_label}, _speaker_map, depth) do
    ["#{indent(depth)}jump #{target_label}"]
  end

  defp render_instruction({:exit, _node}, _speaker_map, depth) do
    ["#{indent(depth)}[end_timeline]"]
  end

  defp render_instruction(_, _speaker_map, _depth), do: []

  # ---------------------------------------------------------------------------
  # Helpers
  # ---------------------------------------------------------------------------

  defp escape_dtl_text(text) when is_binary(text) do
    text
    |> String.replace("\\", "\\\\")
    |> String.replace("#", "\\#")
    |> String.replace("{", "\\{")
    |> String.replace("}", "\\}")
    |> String.replace("[", "\\[")
    |> String.replace("]", "\\]")
  end

  defp escape_dtl_text(_), do: ""

  # Dialogic uses TAB characters for indentation
  defp indent(0), do: ""
  defp indent(n), do: String.duplicate("\t", n)

  defp build_dtl_condition(nil), do: nil
  defp build_dtl_condition(""), do: nil

  defp build_dtl_condition(condition) do
    parsed = Helpers.extract_condition(condition)

    case ExpressionTranspiler.transpile_condition(parsed, :godot) do
      {:ok, expr, _} when expr != "" -> expr
      _ -> nil
    end
  end

  # ---------------------------------------------------------------------------
  # Metadata
  # ---------------------------------------------------------------------------

  defp build_metadata(project, sheets, variables, flows) do
    characters =
      Map.new(sheets, fn sheet ->
        properties =
          sheet.blocks
          |> Enum.reject(& &1.is_constant)
          |> Enum.filter(&(is_binary(&1.variable_name) and &1.variable_name != ""))
          |> Map.new(fn block ->
            {block.variable_name,
             %{
               "type" => to_string(Helpers.infer_variable_type(block)),
               "default" => Helpers.infer_default_value(block)
             }}
          end)

        {sheet.shortcut,
         %{
           "display_name" => sheet.name,
           "storyarn_shortcut" => sheet.shortcut,
           "properties" => properties
         }}
      end)

    variable_folders = build_variable_folders(variables)

    timeline_mapping =
      Map.new(flows, fn flow ->
        key = flow.shortcut || flow.name
        {key, flow_filename(flow)}
      end)

    %{
      "storyarn_dialogic_metadata" => "1.0.0",
      "project" => project.name,
      "characters" => characters,
      "variable_folders" => variable_folders,
      "timeline_mapping" => timeline_mapping
    }
  end

  defp build_variable_folders(variables) do
    variables
    |> Enum.group_by(fn var ->
      Helpers.shortcut_to_identifier(var.sheet_shortcut)
    end)
    |> Map.new(fn {folder, vars} ->
      folder_vars = Map.new(vars, fn var -> {var.variable_name, var.default} end)
      {folder, folder_vars}
    end)
  end
end
