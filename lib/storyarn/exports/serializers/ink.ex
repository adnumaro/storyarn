defmodule Storyarn.Exports.Serializers.Ink do
  @moduledoc """
  Ink script serializer.

  Produces `.ink` text source files for the Ink narrative scripting runtime.
  Reaches ~90% of game developers via 13+ engine runtimes.

  ## Output

  Returns `{:ok, [{filename, content}, ...]}` with:
  - `{project_name}.ink` — main Ink source file
  - `metadata.json` — character/variable mapping sidecar
  """

  @behaviour Storyarn.Exports.Serializer

  alias Storyarn.Exports.{ExportOptions, ExpressionTranspiler}
  alias Storyarn.Exports.Serializers.{GraphTraversal, Helpers}

  @impl true
  def content_type, do: "text/plain"

  @impl true
  def file_extension, do: "ink"

  @impl true
  def format_label, do: "Ink (.ink)"

  @impl true
  def supported_sections, do: [:flows, :sheets]

  @impl true
  def serialize(project_data, %ExportOptions{} = _opts) do
    sheets = project_data.sheets || []
    flows = project_data.flows || []
    variables = Helpers.collect_variables(sheets)
    speaker_map = Helpers.build_speaker_map(sheets)
    tunnel_targets = collect_tunnel_targets(flows)

    ink_lines =
      [
        header_lines(project_data.project),
        variable_declaration_lines(variables),
        Enum.flat_map(flows, &flow_to_knot(&1, speaker_map, tunnel_targets))
      ]
      |> List.flatten()

    ink_source =
      ink_lines
      |> Enum.intersperse("\n")
      |> IO.iodata_to_binary()

    project_name = Helpers.shortcut_to_identifier(project_data.project.slug || "story")

    metadata = build_metadata(project_data.project, sheets, variables)

    {:ok,
     [
       {"#{project_name}.ink", ink_source},
       {"metadata.json", Jason.encode!(metadata, pretty: true)}
     ]}
  end

  @impl true
  def serialize_to_file(_data, _file_path, _options, _callbacks) do
    {:error, :not_implemented}
  end

  # ---------------------------------------------------------------------------
  # Header
  # ---------------------------------------------------------------------------

  defp header_lines(project) do
    [
      "// Generated by Storyarn (https://storyarn.dev)",
      "// Project: #{project.name}",
      ""
    ]
  end

  # ---------------------------------------------------------------------------
  # Variable declarations
  # ---------------------------------------------------------------------------

  defp variable_declaration_lines([]), do: []

  defp variable_declaration_lines(variables) do
    lines =
      Enum.map(variables, fn var ->
        ink_name = Helpers.shortcut_to_identifier(var.full_ref)
        value = Helpers.format_var_declaration_value(var)
        "VAR #{ink_name} = #{value}"
      end)

    ["// === Variables ===" | lines] ++ [""]
  end

  # ---------------------------------------------------------------------------
  # Flow → Knot
  # ---------------------------------------------------------------------------

  defp flow_to_knot(flow, speaker_map, tunnel_targets) do
    knot_name = Helpers.shortcut_to_identifier(flow.shortcut || flow.name || "flow_#{flow.id}")
    {instructions, hub_sections} = GraphTraversal.linearize(flow)
    is_tunnel = MapSet.member?(tunnel_targets, flow.shortcut)
    ctx = %{speaker_map: speaker_map, is_tunnel: is_tunnel}

    knot_lines =
      [
        "// === Flow: #{flow.name} ===",
        "=== #{knot_name} ===",
        ""
      ] ++ render_instructions(instructions, ctx, 0)

    hub_lines =
      Enum.flat_map(hub_sections, fn {label, instrs} ->
        [
          "",
          "= #{label}",
          "" | render_instructions(instrs, ctx, 0)
        ]
      end)

    knot_lines ++ hub_lines ++ [""]
  end

  # ---------------------------------------------------------------------------
  # Instruction rendering
  # ---------------------------------------------------------------------------

  defp render_instructions(instructions, ctx, depth) do
    Enum.flat_map(instructions, &render_instruction(&1, ctx, depth))
  end

  defp render_instruction({:dialogue, node}, ctx, depth) do
    data = node.data || %{}
    text = data |> Helpers.dialogue_text() |> escape_ink_text()
    speaker = Helpers.speaker_name(data, ctx.speaker_map)

    shortcut =
      data |> Helpers.speaker_shortcut(ctx.speaker_map) |> Helpers.shortcut_to_identifier()

    line =
      if speaker && shortcut != "" do
        "#{indent(depth)}#{text} #speaker:#{shortcut}"
      else
        "#{indent(depth)}#{text}"
      end

    stage = data["stage_directions"]

    if stage && stage != "" do
      ["#{indent(depth)}// [Stage: #{Helpers.strip_html(stage)}]", line]
    else
      [line]
    end
  end

  defp render_instruction({:choices_start, _node}, _ctx, _depth), do: []

  defp render_instruction({:choice, resp, _idx}, _ctx, depth) do
    text = (resp["text"] || resp["menu_text"] || "") |> Helpers.strip_html() |> escape_ink_text()
    condition = build_condition_prefix(resp["condition"])

    choice_line =
      if condition do
        "#{indent(depth)}+ #{condition}[#{text}]"
      else
        "#{indent(depth)}+ [#{text}]"
      end

    # Response-level instructions
    assign_lines =
      case resp["instruction_assignments"] do
        [_ | _] = assignments ->
          case ExpressionTranspiler.transpile_instruction(assignments, :ink) do
            {:ok, expr, _} when expr != "" ->
              expr |> String.split("\n") |> Enum.map(&"#{indent(depth + 1)}#{&1}")

            _ ->
              []
          end

        _ ->
          []
      end

    [choice_line | assign_lines]
  end

  defp render_instruction({:choices_end, _node}, _ctx, _depth), do: []

  defp render_instruction({:condition_start, node}, _ctx, depth) do
    data = node.data || %{}
    condition = Helpers.extract_condition(data["condition"])

    case ExpressionTranspiler.transpile_condition(condition, :ink) do
      {:ok, expr, _} when expr != "" ->
        ["#{indent(depth)}{- #{expr}:"]

      _ ->
        ["#{indent(depth)}{- true:"]
    end
  end

  # C1 fix: use "- else:" instead of "- Label:" for second branch
  # M3 fix: for 3+ branches, merge into else with comment (Ink only supports if/else)
  defp render_instruction({:condition_branch, _pin, _label, 0}, _ctx, _depth), do: []

  defp render_instruction({:condition_branch, _pin, _label, 1}, _ctx, depth) do
    ["#{indent(depth)}- else:"]
  end

  defp render_instruction({:condition_branch, _pin, label, _idx}, _ctx, depth) do
    ["#{indent(depth)}// (merged branch: #{label})"]
  end

  defp render_instruction({:condition_end, _node}, _ctx, depth) do
    ["#{indent(depth)}}"]
  end

  defp render_instruction({:instruction, node}, _ctx, depth) do
    data = node.data || %{}
    assignments = Helpers.extract_assignments(data)

    case ExpressionTranspiler.transpile_instruction(assignments, :ink) do
      {:ok, expr, _} when expr != "" ->
        expr |> String.split("\n") |> Enum.map(&"#{indent(depth)}#{&1}")

      _ ->
        []
    end
  end

  defp render_instruction({:scene, node}, _ctx, depth) do
    data = node.data || %{}
    location = data["location"] || data["slug_line"] || ""
    ["#{indent(depth)}# location:#{location}"]
  end

  defp render_instruction({:subflow, node}, _ctx, depth) do
    data = node.data || %{}
    target = Helpers.shortcut_to_identifier(data["flow_shortcut"] || "subflow_#{node.id}")
    ["#{indent(depth)}-> #{target} ->"]
  end

  defp render_instruction({:jump, _node, target_label}, _ctx, depth) do
    ["#{indent(depth)}-> #{target_label}"]
  end

  defp render_instruction({:divert, target_label}, _ctx, depth) do
    ["#{indent(depth)}-> #{target_label}"]
  end

  # C2 fix: tunnel flows use ->-> (tunnel return) instead of -> END
  defp render_instruction({:exit, _node}, %{is_tunnel: true}, depth) do
    ["#{indent(depth)}->->"]
  end

  defp render_instruction({:exit, _node}, _ctx, depth) do
    ["#{indent(depth)}-> END"]
  end

  defp render_instruction(_, _ctx, _depth), do: []

  # ---------------------------------------------------------------------------
  # Helpers
  # ---------------------------------------------------------------------------

  defp escape_ink_text(text) do
    text
    |> String.replace("\\", "\\\\")
    |> String.replace("[", "\\[")
    |> String.replace("]", "\\]")
  end

  defp collect_tunnel_targets(flows) do
    flows
    |> Enum.flat_map(fn flow ->
      (flow.nodes || [])
      |> Enum.filter(&(&1.type == "subflow"))
      |> Enum.map(& &1.data["flow_shortcut"])
      |> Enum.reject(&is_nil/1)
    end)
    |> MapSet.new()
  end

  defp indent(0), do: ""
  defp indent(n), do: String.duplicate("    ", n)

  defp build_condition_prefix(nil), do: nil
  defp build_condition_prefix(""), do: nil

  defp build_condition_prefix(condition) do
    parsed = Helpers.extract_condition(condition)

    case ExpressionTranspiler.transpile_condition(parsed, :ink) do
      {:ok, expr, _} when expr != "" -> "{#{expr}} "
      _ -> nil
    end
  end

  # ---------------------------------------------------------------------------
  # Metadata sidecar
  # ---------------------------------------------------------------------------

  defp build_metadata(project, sheets, variables) do
    characters =
      Map.new(sheets, fn sheet ->
        props =
          sheet.blocks
          |> Enum.reject(& &1.is_constant)
          |> Enum.filter(&(is_binary(&1.variable_name) and &1.variable_name != ""))
          |> Map.new(fn block ->
            {block.variable_name, Helpers.infer_default_value(block)}
          end)

        {sheet.shortcut, %{"name" => sheet.name, "properties" => props}}
      end)

    variable_mapping =
      Map.new(variables, fn var ->
        {var.full_ref, Helpers.shortcut_to_identifier(var.full_ref)}
      end)

    %{
      "storyarn_ink_metadata" => "1.0.0",
      "project" => project.name,
      "characters" => characters,
      "variable_mapping" => variable_mapping
    }
  end
end
