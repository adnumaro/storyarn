defmodule Storyarn.Exports.Serializers.GodotDialogicTest do
  use Storyarn.DataCase, async: true

  alias Storyarn.Exports.{DataCollector, ExportOptions}
  alias Storyarn.Exports.Serializers.GodotDialogic

  alias Storyarn.Repo

  import Storyarn.AccountsFixtures
  import Storyarn.FlowsFixtures
  import Storyarn.ProjectsFixtures
  import Storyarn.SheetsFixtures

  # =============================================================================
  # Setup
  # =============================================================================

  defp reload_flow(flow), do: Repo.preload(flow, [:nodes, :connections], force: true)

  defp create_project(_context) do
    user = user_fixture()
    project = project_fixture(user)
    %{user: user, project: project}
  end

  defp default_opts do
    {:ok, opts} = ExportOptions.new(%{format: :godot, validate_before_export: false})
    opts
  end

  defp export_dialogic(project, opts \\ nil) do
    opts = opts || default_opts()
    project_data = DataCollector.collect(project.id, opts)
    {:ok, files} = GodotDialogic.serialize(project_data, opts)
    files
  end

  defp dtl_source(files) do
    {_name, content} = Enum.find(files, fn {name, _} -> String.ends_with?(name, ".dtl") end)
    content
  end

  defp metadata(files) do
    {_name, content} = Enum.find(files, fn {name, _} -> name == "metadata.json" end)
    Jason.decode!(content)
  end

  defp lines(source), do: String.split(source, "\n")

  defp has_line?(source, expected) do
    source |> lines() |> Enum.any?(&(&1 == expected))
  end

  defp has_line_matching?(source, regex) do
    source |> lines() |> Enum.any?(&Regex.match?(regex, &1))
  end

  # =============================================================================
  # Behaviour callbacks
  # =============================================================================

  describe "behaviour callbacks" do
    test "content_type returns text/plain" do
      assert GodotDialogic.content_type() == "text/plain"
    end

    test "file_extension returns dtl" do
      assert GodotDialogic.file_extension() == "dtl"
    end

    test "format_label returns human-readable name" do
      assert GodotDialogic.format_label() == "Godot Dialogic (.dtl)"
    end

    test "supported_sections lists flows and sheets" do
      sections = GodotDialogic.supported_sections()
      assert :flows in sections
      assert :sheets in sections
    end

    test "serialize_to_file returns not_implemented" do
      assert {:error, :not_implemented} = GodotDialogic.serialize_to_file(nil, "", nil, [])
    end
  end

  # =============================================================================
  # Empty project
  # =============================================================================

  describe "empty project export" do
    setup [:create_project]

    test "produces metadata.json with no flows", %{project: project} do
      files = export_dialogic(project)
      assert length(files) == 1
      assert Enum.any?(files, fn {name, _} -> name == "metadata.json" end)
    end

    test "metadata has required fields", %{project: project} do
      meta = metadata(export_dialogic(project))
      assert meta["storyarn_dialogic_metadata"] == "1.0.0"
      assert is_binary(meta["project"])
    end
  end

  # =============================================================================
  # Single flow export
  # =============================================================================

  describe "single flow export" do
    setup [:create_project]

    test "produces dtl file and metadata", %{project: project} do
      _flow = flow_fixture(project, %{name: "Test Flow"})

      files = export_dialogic(project)
      assert Enum.any?(files, fn {name, _} -> String.ends_with?(name, ".dtl") end)
      assert Enum.any?(files, fn {name, _} -> name == "metadata.json" end)
    end

    test "dtl file has header comment", %{project: project} do
      _flow = flow_fixture(project, %{name: "Test Flow"})

      source = dtl_source(export_dialogic(project))
      assert source =~ "# Generated by Storyarn"
    end
  end

  # =============================================================================
  # Dialogue rendering
  # =============================================================================

  describe "dialogue rendering" do
    setup [:create_project]

    test "dialogue with speaker uses Speaker: Text format", %{project: project} do
      sheet = sheet_fixture(project, %{name: "Jaime"})
      flow = flow_fixture(project, %{name: "Speaker Flow"})
      flow = reload_flow(flow)
      entry = Enum.find(flow.nodes, &(&1.type == "entry"))

      dialogue =
        node_fixture(flow, %{
          type: "dialogue",
          data: %{
            "text" => "Hello traveler!",
            "speaker_sheet_id" => sheet.id,
            "responses" => []
          }
        })

      connection_fixture(flow, entry, dialogue)

      source = dtl_source(export_dialogic(project))
      assert source =~ "Jaime: Hello traveler!"
    end

    test "dialogue without speaker renders plain text", %{project: project} do
      flow = flow_fixture(project, %{name: "No Speaker Flow"})
      flow = reload_flow(flow)
      entry = Enum.find(flow.nodes, &(&1.type == "entry"))

      dialogue =
        node_fixture(flow, %{
          type: "dialogue",
          data: %{
            "text" => "The wind howls.",
            "speaker_sheet_id" => nil,
            "responses" => []
          }
        })

      connection_fixture(flow, entry, dialogue)

      source = dtl_source(export_dialogic(project))
      assert has_line?(source, "The wind howls.")
      refute has_line_matching?(source, ~r/^\w+: The wind howls\.$/)
    end

    test "stage directions render as comments", %{project: project} do
      flow = flow_fixture(project, %{name: "Stage Flow"})
      flow = reload_flow(flow)
      entry = Enum.find(flow.nodes, &(&1.type == "entry"))

      dialogue =
        node_fixture(flow, %{
          type: "dialogue",
          data: %{
            "text" => "Hello!",
            "speaker_sheet_id" => nil,
            "stage_directions" => "looks around nervously",
            "responses" => []
          }
        })

      connection_fixture(flow, entry, dialogue)

      source = dtl_source(export_dialogic(project))
      assert source =~ "# [Stage: looks around nervously]"
    end

    test "strips HTML from dialogue text", %{project: project} do
      flow = flow_fixture(project, %{name: "HTML Flow"})
      flow = reload_flow(flow)
      entry = Enum.find(flow.nodes, &(&1.type == "entry"))

      dialogue =
        node_fixture(flow, %{
          type: "dialogue",
          data: %{
            "text" => "<p>Hello <em>world</em>!</p>",
            "speaker_sheet_id" => nil,
            "responses" => []
          }
        })

      connection_fixture(flow, entry, dialogue)

      source = dtl_source(export_dialogic(project))
      assert source =~ "Hello world!"
      refute source =~ "<p>"
      refute source =~ "<em>"
    end
  end

  # =============================================================================
  # Choice rendering
  # =============================================================================

  describe "choice rendering" do
    setup [:create_project]

    test "responses become - Text choices", %{project: project} do
      flow = flow_fixture(project, %{name: "Choice Flow"})
      flow = reload_flow(flow)
      entry = Enum.find(flow.nodes, &(&1.type == "entry"))

      dialogue =
        node_fixture(flow, %{
          type: "dialogue",
          data: %{
            "text" => "What now?",
            "speaker_sheet_id" => nil,
            "responses" => [
              %{"id" => "r1", "text" => "Fight", "condition" => nil, "instruction" => nil},
              %{"id" => "r2", "text" => "Flee", "condition" => nil, "instruction" => nil}
            ]
          }
        })

      connection_fixture(flow, entry, dialogue)

      source = dtl_source(export_dialogic(project))
      assert source =~ "- Fight"
      assert source =~ "- Flee"
    end

    test "dialogue with speaker AND responses", %{project: project} do
      sheet = sheet_fixture(project, %{name: "Merchant"})

      flow = flow_fixture(project, %{name: "Speaker Choice Flow"})
      flow = reload_flow(flow)
      entry = Enum.find(flow.nodes, &(&1.type == "entry"))

      dialogue =
        node_fixture(flow, %{
          type: "dialogue",
          data: %{
            "text" => "What would you like?",
            "speaker_sheet_id" => sheet.id,
            "responses" => [
              %{"id" => "r1", "text" => "Buy", "condition" => nil, "instruction" => nil},
              %{"id" => "r2", "text" => "Sell", "condition" => nil, "instruction" => nil}
            ]
          }
        })

      connection_fixture(flow, entry, dialogue)

      source = dtl_source(export_dialogic(project))
      assert has_line?(source, "Merchant: What would you like?")
      assert has_line?(source, "- Buy")
      assert has_line?(source, "- Sell")
    end
  end

  # =============================================================================
  # Condition rendering
  # =============================================================================

  describe "condition rendering" do
    setup [:create_project]

    test "condition produces if/else blocks", %{project: project} do
      sheet = sheet_fixture(project, %{name: "Stats"})

      block_fixture(sheet, %{
        type: "boolean",
        config: %{"label" => "Alive"},
        value: %{"boolean" => true}
      })

      flow = flow_fixture(project, %{name: "Cond Flow"})
      flow = reload_flow(flow)
      entry = Enum.find(flow.nodes, &(&1.type == "entry"))

      condition =
        node_fixture(flow, %{
          type: "condition",
          data: %{
            "condition" =>
              Jason.encode!(%{
                "logic" => "all",
                "rules" => [
                  %{
                    "sheet" => sheet.shortcut,
                    "variable" => "alive",
                    "operator" => "is_true"
                  }
                ]
              }),
            "cases" => [
              %{"id" => "true", "value" => "true", "label" => "True"},
              %{"id" => "false", "value" => "false", "label" => "False"}
            ]
          }
        })

      true_dialogue =
        node_fixture(flow, %{
          type: "dialogue",
          data: %{"text" => "Still alive!", "speaker_sheet_id" => nil, "responses" => []}
        })

      false_dialogue =
        node_fixture(flow, %{
          type: "dialogue",
          data: %{"text" => "Dead...", "speaker_sheet_id" => nil, "responses" => []}
        })

      connection_fixture(flow, entry, condition)
      connection_fixture(flow, condition, true_dialogue, %{source_pin: "true"})
      connection_fixture(flow, condition, false_dialogue, %{source_pin: "false"})

      source = dtl_source(export_dialogic(project))
      assert has_line_matching?(source, ~r/^if \{.+\} == true:$/)
      assert has_line?(source, "else:")
      assert source =~ "Still alive!"
      assert source =~ "Dead..."
    end

    test "condition with nil expression renders if true:", %{project: project} do
      flow = flow_fixture(project, %{name: "Nil Cond Flow"})
      flow = reload_flow(flow)
      entry = Enum.find(flow.nodes, &(&1.type == "entry"))

      condition =
        node_fixture(flow, %{
          type: "condition",
          data: %{
            "condition" => nil,
            "cases" => [
              %{"id" => "true", "value" => "true", "label" => "True"}
            ]
          }
        })

      connection_fixture(flow, entry, condition)

      source = dtl_source(export_dialogic(project))
      assert source =~ "if true:"
    end
  end

  # =============================================================================
  # Instruction rendering
  # =============================================================================

  describe "instruction rendering" do
    setup [:create_project]

    test "instruction produces set commands", %{project: project} do
      sheet = sheet_fixture(project, %{name: "Flags"})

      block_fixture(sheet, %{
        type: "boolean",
        config: %{"label" => "Met"},
        value: %{"boolean" => false}
      })

      flow = flow_fixture(project, %{name: "Inst Flow"})
      flow = reload_flow(flow)
      entry = Enum.find(flow.nodes, &(&1.type == "entry"))

      instruction =
        node_fixture(flow, %{
          type: "instruction",
          data: %{
            "assignments" => [
              %{
                "sheet" => sheet.shortcut,
                "variable" => "met",
                "operator" => "set_true"
              }
            ]
          }
        })

      connection_fixture(flow, entry, instruction)

      source = dtl_source(export_dialogic(project))
      assert has_line_matching?(source, ~r/^set \{.+\.met\} = true$/)
    end

    test "instruction with empty assignments produces no output", %{project: project} do
      flow = flow_fixture(project, %{name: "Empty Inst Flow"})
      flow = reload_flow(flow)
      entry = Enum.find(flow.nodes, &(&1.type == "entry"))

      instruction =
        node_fixture(flow, %{
          type: "instruction",
          data: %{"assignments" => []}
        })

      exit_node = node_fixture(flow, %{type: "exit", data: %{}})

      connection_fixture(flow, entry, instruction)
      connection_fixture(flow, instruction, exit_node)

      source = dtl_source(export_dialogic(project))
      # Should still produce valid dtl with header
      assert source =~ "# Generated by Storyarn"
    end
  end

  # =============================================================================
  # Navigation
  # =============================================================================

  describe "navigation" do
    setup [:create_project]

    test "exit node produces [end_timeline]", %{project: project} do
      flow = flow_fixture(project, %{name: "Exit Flow"})
      flow = reload_flow(flow)
      entry = Enum.find(flow.nodes, &(&1.type == "entry"))
      exit_node = node_fixture(flow, %{type: "exit", data: %{}})
      connection_fixture(flow, entry, exit_node)

      source = dtl_source(export_dialogic(project))
      assert source =~ "[end_timeline]"
    end

    test "hub produces label section", %{project: project} do
      flow = flow_fixture(project, %{name: "Hub Flow"})
      flow = reload_flow(flow)
      entry = Enum.find(flow.nodes, &(&1.type == "entry"))

      hub =
        node_fixture(flow, %{
          type: "hub",
          data: %{"label" => "checkpoint"}
        })

      jump =
        node_fixture(flow, %{
          type: "jump",
          data: %{"hub_id" => hub.id}
        })

      dialogue_after_hub =
        node_fixture(flow, %{
          type: "dialogue",
          data: %{"text" => "At checkpoint!", "speaker_sheet_id" => nil, "responses" => []}
        })

      connection_fixture(flow, entry, jump)
      connection_fixture(flow, hub, dialogue_after_hub)

      source = dtl_source(export_dialogic(project))
      assert source =~ "jump checkpoint"
      assert source =~ "label checkpoint"
    end

    test "jump to external flow renders jump", %{project: project} do
      flow = flow_fixture(project, %{name: "Jump Flow"})
      flow = reload_flow(flow)
      entry = Enum.find(flow.nodes, &(&1.type == "entry"))

      jump =
        node_fixture(flow, %{
          type: "jump",
          data: %{"target_flow_shortcut" => "act2.beginning"}
        })

      connection_fixture(flow, entry, jump)

      source = dtl_source(export_dialogic(project))
      assert source =~ "jump act2_beginning"
    end

    test "subflow renders jump with trailing slash", %{project: project} do
      flow = flow_fixture(project, %{name: "Subflow Flow"})
      flow = reload_flow(flow)
      entry = Enum.find(flow.nodes, &(&1.type == "entry"))

      subflow =
        node_fixture(flow, %{
          type: "subflow",
          data: %{"flow_shortcut" => "side_quest.rescue"}
        })

      connection_fixture(flow, entry, subflow)

      source = dtl_source(export_dialogic(project))
      assert source =~ "jump side_quest_rescue/"
    end

    test "scene node renders location comment", %{project: project} do
      flow = flow_fixture(project, %{name: "Scene Flow"})
      flow = reload_flow(flow)
      entry = Enum.find(flow.nodes, &(&1.type == "entry"))

      scene =
        node_fixture(flow, %{
          type: "scene",
          data: %{"location" => "Tavern Interior"}
        })

      connection_fixture(flow, entry, scene)

      source = dtl_source(export_dialogic(project))
      assert source =~ "# location: Tavern Interior"
    end
  end

  # =============================================================================
  # Special character escaping
  # =============================================================================

  describe "special character escaping" do
    setup [:create_project]

    test "dialogue text with hashtag escapes it", %{project: project} do
      flow = flow_fixture(project, %{name: "Escape Hash"})
      flow = reload_flow(flow)
      entry = Enum.find(flow.nodes, &(&1.type == "entry"))

      dialogue =
        node_fixture(flow, %{
          type: "dialogue",
          data: %{
            "text" => "Check item #3",
            "speaker_sheet_id" => nil,
            "responses" => []
          }
        })

      connection_fixture(flow, entry, dialogue)

      source = dtl_source(export_dialogic(project))
      assert source =~ "Check item \\#3"
    end

    test "dialogue text with curly braces escapes them", %{project: project} do
      flow = flow_fixture(project, %{name: "Escape Braces"})
      flow = reload_flow(flow)
      entry = Enum.find(flow.nodes, &(&1.type == "entry"))

      dialogue =
        node_fixture(flow, %{
          type: "dialogue",
          data: %{
            "text" => "Use {potion}",
            "speaker_sheet_id" => nil,
            "responses" => []
          }
        })

      connection_fixture(flow, entry, dialogue)

      source = dtl_source(export_dialogic(project))
      assert source =~ "Use \\{potion\\}"
    end

    test "dialogue text with brackets escapes them", %{project: project} do
      flow = flow_fixture(project, %{name: "Escape Brackets"})
      flow = reload_flow(flow)
      entry = Enum.find(flow.nodes, &(&1.type == "entry"))

      dialogue =
        node_fixture(flow, %{
          type: "dialogue",
          data: %{
            "text" => "Check [inventory]",
            "speaker_sheet_id" => nil,
            "responses" => []
          }
        })

      connection_fixture(flow, entry, dialogue)

      source = dtl_source(export_dialogic(project))
      assert source =~ "Check \\[inventory\\]"
    end

    test "dialogue with backslash escapes it", %{project: project} do
      flow = flow_fixture(project, %{name: "Escape Backslash"})
      flow = reload_flow(flow)
      entry = Enum.find(flow.nodes, &(&1.type == "entry"))

      dialogue =
        node_fixture(flow, %{
          type: "dialogue",
          data: %{
            "text" => "path\\to\\file",
            "speaker_sheet_id" => nil,
            "responses" => []
          }
        })

      connection_fixture(flow, entry, dialogue)

      source = dtl_source(export_dialogic(project))
      assert source =~ "path\\\\to\\\\file"
    end

    test "response text with special chars escapes them", %{project: project} do
      flow = flow_fixture(project, %{name: "Escape Choice"})
      flow = reload_flow(flow)
      entry = Enum.find(flow.nodes, &(&1.type == "entry"))

      dialogue =
        node_fixture(flow, %{
          type: "dialogue",
          data: %{
            "text" => "What now?",
            "speaker_sheet_id" => nil,
            "responses" => [
              %{"id" => "r1", "text" => "Option #1", "condition" => nil, "instruction" => nil}
            ]
          }
        })

      connection_fixture(flow, entry, dialogue)

      source = dtl_source(export_dialogic(project))
      assert source =~ "- Option \\#1"
    end
  end

  # =============================================================================
  # Metadata sidecar
  # =============================================================================

  describe "metadata sidecar" do
    setup [:create_project]

    test "includes characters with display_name", %{project: project} do
      sheet = sheet_fixture(project, %{name: "Hero"})

      meta = metadata(export_dialogic(project))
      assert is_map(meta["characters"])
      char = meta["characters"][sheet.shortcut]
      assert char["display_name"] == "Hero"
      assert char["storyarn_shortcut"] == sheet.shortcut
    end

    test "includes character properties", %{project: project} do
      sheet = sheet_fixture(project, %{name: "Hero"})

      block_fixture(sheet, %{
        type: "number",
        config: %{"label" => "Health"},
        value: %{"number" => 100}
      })

      meta = metadata(export_dialogic(project))
      char = meta["characters"][sheet.shortcut]
      health = char["properties"]["health"]
      assert health["type"] == "number"
      assert health["default"] == 100
    end

    test "includes variable_folders grouped by sheet", %{project: project} do
      sheet = sheet_fixture(project, %{name: "Hero"})

      block_fixture(sheet, %{
        type: "number",
        config: %{"label" => "Health"},
        value: %{"number" => 100}
      })

      block_fixture(sheet, %{
        type: "boolean",
        config: %{"label" => "Alive"},
        value: %{"boolean" => true}
      })

      meta = metadata(export_dialogic(project))
      folders = meta["variable_folders"]
      assert is_map(folders)

      # Sheet shortcut gets underscored as folder name
      folder_keys = Map.keys(folders)
      assert folder_keys != []
    end

    test "includes timeline_mapping", %{project: project} do
      flow = flow_fixture(project, %{name: "Main Quest"})

      meta = metadata(export_dialogic(project))
      mapping = meta["timeline_mapping"]
      key = flow.shortcut || flow.name
      assert is_binary(mapping[key])
      assert String.ends_with?(mapping[key], ".dtl")
    end

    test "includes project name", %{project: project} do
      meta = metadata(export_dialogic(project))
      assert meta["project"] == project.name
    end
  end

  # =============================================================================
  # Multi-flow export
  # =============================================================================

  describe "multi-flow export" do
    setup [:create_project]

    test "produces one dtl per flow plus one metadata.json, all with headers", %{
      project: project
    } do
      for i <- 1..3, do: flow_fixture(project, %{name: "Flow #{i}"})

      files = export_dialogic(project)
      dtl_files = Enum.filter(files, fn {name, _} -> String.ends_with?(name, ".dtl") end)
      meta_files = Enum.filter(files, fn {name, _} -> name == "metadata.json" end)

      assert length(dtl_files) == 3
      assert length(meta_files) == 1

      Enum.each(dtl_files, fn {_name, content} ->
        assert content =~ "# Generated by Storyarn"
      end)
    end
  end

  # =============================================================================
  # Complex flows
  # =============================================================================

  describe "complex flow chains" do
    setup [:create_project]

    test "entry -> dialogue -> instruction -> exit chain", %{project: project} do
      sheet = sheet_fixture(project, %{name: "Flags"})

      block_fixture(sheet, %{
        type: "boolean",
        config: %{"label" => "Visited"},
        value: %{"boolean" => false}
      })

      flow = flow_fixture(project, %{name: "Chain Flow"})
      flow = reload_flow(flow)
      entry = Enum.find(flow.nodes, &(&1.type == "entry"))

      dialogue =
        node_fixture(flow, %{
          type: "dialogue",
          data: %{"text" => "Welcome!", "speaker_sheet_id" => nil, "responses" => []}
        })

      instruction =
        node_fixture(flow, %{
          type: "instruction",
          data: %{
            "assignments" => [
              %{"sheet" => sheet.shortcut, "variable" => "visited", "operator" => "set_true"}
            ]
          }
        })

      exit_node = node_fixture(flow, %{type: "exit", data: %{}})

      connection_fixture(flow, entry, dialogue)
      connection_fixture(flow, dialogue, instruction)
      connection_fixture(flow, instruction, exit_node)

      source = dtl_source(export_dialogic(project))
      assert source =~ "Welcome!"
      assert has_line_matching?(source, ~r/^set \{.+\.visited\} = true$/)
      assert has_line?(source, "[end_timeline]")
    end

    test "entry -> scene -> dialogue chain", %{project: project} do
      flow = flow_fixture(project, %{name: "Scene Chain"})
      flow = reload_flow(flow)
      entry = Enum.find(flow.nodes, &(&1.type == "entry"))

      scene =
        node_fixture(flow, %{
          type: "scene",
          data: %{"location" => "Dark Forest"}
        })

      dialogue =
        node_fixture(flow, %{
          type: "dialogue",
          data: %{"text" => "The forest is dark.", "speaker_sheet_id" => nil, "responses" => []}
        })

      connection_fixture(flow, entry, scene)
      connection_fixture(flow, scene, dialogue)

      source = dtl_source(export_dialogic(project))
      assert source =~ "# location: Dark Forest"
      assert source =~ "The forest is dark."
    end

    test "dialogue with choices having conditions and instructions", %{project: project} do
      sheet = sheet_fixture(project, %{name: "Hero"})

      block_fixture(sheet, %{
        type: "number",
        config: %{"label" => "Gold"},
        value: %{"number" => 100}
      })

      flow = flow_fixture(project, %{name: "Complex Choice"})
      flow = reload_flow(flow)
      entry = Enum.find(flow.nodes, &(&1.type == "entry"))

      dialogue =
        node_fixture(flow, %{
          type: "dialogue",
          data: %{
            "text" => "Buy something?",
            "speaker_sheet_id" => nil,
            "responses" => [
              %{
                "id" => "r1",
                "text" => "Buy sword",
                "condition" =>
                  Jason.encode!(%{
                    "logic" => "all",
                    "rules" => [
                      %{
                        "sheet" => sheet.shortcut,
                        "variable" => "gold",
                        "operator" => "greater_than",
                        "value" => "50"
                      }
                    ]
                  }),
                "instruction" =>
                  Jason.encode!([
                    %{
                      "sheet" => sheet.shortcut,
                      "variable" => "gold",
                      "operator" => "subtract",
                      "value" => "50"
                    }
                  ])
              },
              %{"id" => "r2", "text" => "Leave", "condition" => nil, "instruction" => nil}
            ]
          }
        })

      connection_fixture(flow, entry, dialogue)

      source = dtl_source(export_dialogic(project))
      assert source =~ "Buy something?"
      assert source =~ "- Buy sword [if"
      assert source =~ "- Leave"
    end
  end

  # =============================================================================
  # Error paths
  # =============================================================================

  describe "error paths" do
    setup [:create_project]

    test "handles flow with only entry node", %{project: project} do
      _flow = flow_fixture(project, %{name: "Empty Flow"})
      files = export_dialogic(project)
      source = dtl_source(files)
      assert is_binary(source)
      assert source =~ "# Generated by Storyarn"
    end

    test "handles dialogue with nil data fields", %{project: project} do
      flow = flow_fixture(project, %{name: "Nil Data"})
      flow = reload_flow(flow)
      entry = Enum.find(flow.nodes, &(&1.type == "entry"))

      dialogue =
        node_fixture(flow, %{
          type: "dialogue",
          data: %{
            "text" => nil,
            "speaker_sheet_id" => nil,
            "responses" => []
          }
        })

      connection_fixture(flow, entry, dialogue)

      files = export_dialogic(project)
      source = dtl_source(files)
      assert source =~ "# Generated by Storyarn"
    end

    test "handles condition with empty expression", %{project: project} do
      flow = flow_fixture(project, %{name: "Empty Cond"})
      flow = reload_flow(flow)
      entry = Enum.find(flow.nodes, &(&1.type == "entry"))

      condition =
        node_fixture(flow, %{
          type: "condition",
          data: %{
            "condition" => "",
            "cases" => [
              %{"id" => "true", "value" => "true", "label" => "True"},
              %{"id" => "false", "value" => "false", "label" => "False"}
            ]
          }
        })

      connection_fixture(flow, entry, condition)

      files = export_dialogic(project)
      source = dtl_source(files)
      assert source =~ "if true:"
    end

    test "constant blocks are excluded from metadata", %{project: project} do
      sheet = sheet_fixture(project, %{name: "Constants"})

      block_fixture(sheet, %{
        type: "number",
        config: %{"label" => "Max HP"},
        value: %{"number" => 999},
        is_constant: true
      })

      meta = metadata(export_dialogic(project))
      char = meta["characters"][sheet.shortcut]
      assert char["properties"] == %{}
    end
  end

  # =============================================================================
  # TAB indentation
  # =============================================================================

  describe "TAB indentation" do
    setup [:create_project]

    test "condition if/else structure renders correctly", %{project: project} do
      sheet = sheet_fixture(project, %{name: "PC"})

      block_fixture(sheet, %{
        type: "boolean",
        config: %{"label" => "Alive"},
        value: %{"boolean" => true}
      })

      flow = flow_fixture(project, %{name: "TAB Cond Flow"})
      flow = reload_flow(flow)
      entry = Enum.find(flow.nodes, &(&1.type == "entry"))

      condition =
        node_fixture(flow, %{
          type: "condition",
          data: %{
            "condition" =>
              Jason.encode!(%{
                "logic" => "all",
                "rules" => [
                  %{
                    "sheet" => sheet.shortcut,
                    "variable" => "alive",
                    "operator" => "is_true"
                  }
                ]
              }),
            "cases" => [
              %{"id" => "true", "value" => "true", "label" => "True"},
              %{"id" => "false", "value" => "false", "label" => "False"}
            ]
          }
        })

      true_dialogue =
        node_fixture(flow, %{
          type: "dialogue",
          data: %{"text" => "Alive!", "speaker_sheet_id" => nil, "responses" => []}
        })

      false_dialogue =
        node_fixture(flow, %{
          type: "dialogue",
          data: %{"text" => "Dead...", "speaker_sheet_id" => nil, "responses" => []}
        })

      connection_fixture(flow, entry, condition)
      connection_fixture(flow, condition, true_dialogue, %{source_pin: "true"})
      connection_fixture(flow, condition, false_dialogue, %{source_pin: "false"})

      source = dtl_source(export_dialogic(project))

      # if line has no leading TAB
      assert has_line_matching?(source, ~r/^if .+:$/)
      # true branch content
      assert source =~ "Alive!"
      # else marker
      assert has_line?(source, "else:")
      # false branch content
      assert source =~ "Dead..."

      # NOTE: Dialogic 2 expects TAB indentation inside condition branches,
      # but the serializer currently renders branch content at depth 0.
      # When depth-tracking is added, update these assertions:
      #   assert has_line?(source, "\tAlive!")
      #   assert has_line?(source, "\tDead...")
    end

    test "choice instructions are TAB-indented", %{project: project} do
      sheet = sheet_fixture(project, %{name: "Inventory"})

      block_fixture(sheet, %{
        type: "number",
        config: %{"label" => "Swords"},
        value: %{"number" => 0}
      })

      flow = flow_fixture(project, %{name: "TAB Choice Flow"})
      flow = reload_flow(flow)
      entry = Enum.find(flow.nodes, &(&1.type == "entry"))

      dialogue =
        node_fixture(flow, %{
          type: "dialogue",
          data: %{
            "text" => "Take the sword?",
            "speaker_sheet_id" => nil,
            "responses" => [
              %{
                "id" => "r1",
                "text" => "Take it",
                "condition" => nil,
                "instruction" =>
                  Jason.encode!([
                    %{
                      "sheet" => sheet.shortcut,
                      "variable" => "swords",
                      "operator" => "add",
                      "value" => "1"
                    }
                  ])
              },
              %{"id" => "r2", "text" => "Leave it", "condition" => nil, "instruction" => nil}
            ]
          }
        })

      connection_fixture(flow, entry, dialogue)

      source = dtl_source(export_dialogic(project))

      # choice at depth 0 (no leading TAB)
      assert has_line_matching?(source, ~r/^- Take it$/)
      # instruction indented with TAB under the choice
      assert has_line_matching?(source, ~r/^\tset \{.+\.swords\} \+= 1$/)
    end
  end

  # =============================================================================
  # Flow naming
  # =============================================================================

  describe "flow naming" do
    setup [:create_project]

    test "dtl filename uses shortcut as identifier", %{project: project} do
      flow = flow_fixture(project, %{name: "Tavern Scene"})

      files = export_dialogic(project)
      filenames = Enum.map(files, fn {name, _} -> name end)
      expected = "#{String.replace(flow.shortcut, ~r/[.\-]/, "_")}.dtl"
      assert expected in filenames
    end

    test "dtl filename with digit-starting shortcut gets _ prefix", %{project: project} do
      # Force a shortcut that starts with a digit
      flow = flow_fixture(project, %{name: "1st Quest"})
      flow = Repo.preload(flow, [], force: true)

      files = export_dialogic(project)
      filenames = Enum.map(files, fn {name, _} -> name end)
      identifier = String.replace(flow.shortcut, ~r/[.\-]/, "_")

      expected =
        if String.match?(identifier, ~r/^[0-9]/),
          do: "_#{identifier}.dtl",
          else: "#{identifier}.dtl"

      assert expected in filenames
    end
  end

  # =============================================================================
  # Additional coverage
  # =============================================================================

  describe "additional coverage" do
    setup [:create_project]

    test "scene with slug_line fallback renders location comment", %{project: project} do
      flow = flow_fixture(project, %{name: "Slug Scene Flow"})
      flow = reload_flow(flow)
      entry = Enum.find(flow.nodes, &(&1.type == "entry"))

      scene =
        node_fixture(flow, %{
          type: "scene",
          data: %{"slug_line" => "INT. TAVERN"}
        })

      connection_fixture(flow, entry, scene)

      source = dtl_source(export_dialogic(project))
      assert has_line?(source, "# location: INT. TAVERN")
    end

    test "subflow with nil shortcut uses node id fallback", %{project: project} do
      flow = flow_fixture(project, %{name: "Nil Subflow Flow"})
      flow = reload_flow(flow)
      entry = Enum.find(flow.nodes, &(&1.type == "entry"))

      subflow =
        node_fixture(flow, %{
          type: "subflow",
          data: %{}
        })

      connection_fixture(flow, entry, subflow)

      source = dtl_source(export_dialogic(project))
      assert has_line_matching?(source, ~r/^jump subflow_#{subflow.id}\/$/)
    end

    test "response falls back to menu_text when text is nil", %{project: project} do
      flow = flow_fixture(project, %{name: "Menu Text Flow"})
      flow = reload_flow(flow)
      entry = Enum.find(flow.nodes, &(&1.type == "entry"))

      dialogue =
        node_fixture(flow, %{
          type: "dialogue",
          data: %{
            "text" => "Choose wisely.",
            "speaker_sheet_id" => nil,
            "responses" => [
              %{
                "id" => "r1",
                "text" => nil,
                "menu_text" => "Go back",
                "condition" => nil,
                "instruction" => nil
              }
            ]
          }
        })

      connection_fixture(flow, entry, dialogue)

      source = dtl_source(export_dialogic(project))
      assert has_line?(source, "- Go back")
    end

    test "instruction with set numeric value", %{project: project} do
      sheet = sheet_fixture(project, %{name: "Stats"})

      block_fixture(sheet, %{
        type: "number",
        config: %{"label" => "Health"},
        value: %{"number" => 100}
      })

      flow = flow_fixture(project, %{name: "Set Num Flow"})
      flow = reload_flow(flow)
      entry = Enum.find(flow.nodes, &(&1.type == "entry"))

      instruction =
        node_fixture(flow, %{
          type: "instruction",
          data: %{
            "assignments" => [
              %{
                "sheet" => sheet.shortcut,
                "variable" => "health",
                "operator" => "set",
                "value" => "50"
              }
            ]
          }
        })

      connection_fixture(flow, entry, instruction)

      source = dtl_source(export_dialogic(project))
      assert has_line_matching?(source, ~r/^set \{.+\.health\} = 50$/)
    end

    test "instruction with add operator", %{project: project} do
      sheet = sheet_fixture(project, %{name: "Coins"})

      block_fixture(sheet, %{
        type: "number",
        config: %{"label" => "Gold"},
        value: %{"number" => 0}
      })

      flow = flow_fixture(project, %{name: "Add Op Flow"})
      flow = reload_flow(flow)
      entry = Enum.find(flow.nodes, &(&1.type == "entry"))

      instruction =
        node_fixture(flow, %{
          type: "instruction",
          data: %{
            "assignments" => [
              %{
                "sheet" => sheet.shortcut,
                "variable" => "gold",
                "operator" => "add",
                "value" => "10"
              }
            ]
          }
        })

      connection_fixture(flow, entry, instruction)

      source = dtl_source(export_dialogic(project))
      assert has_line_matching?(source, ~r/^set \{.+\.gold\} \+= 10$/)
    end

    test "metadata with multiple sheets", %{project: project} do
      sheet1 = sheet_fixture(project, %{name: "Hero"})

      block_fixture(sheet1, %{
        type: "number",
        config: %{"label" => "Health"},
        value: %{"number" => 100}
      })

      sheet2 = sheet_fixture(project, %{name: "Villain"})

      block_fixture(sheet2, %{
        type: "boolean",
        config: %{"label" => "Defeated"},
        value: %{"boolean" => false}
      })

      meta = metadata(export_dialogic(project))

      assert Map.has_key?(meta["characters"], sheet1.shortcut)
      assert Map.has_key?(meta["characters"], sheet2.shortcut)
      assert Map.has_key?(meta["variable_folders"], String.replace(sheet1.shortcut, ".", "_"))
      assert Map.has_key?(meta["variable_folders"], String.replace(sheet2.shortcut, ".", "_"))
    end

    test "variable folder uses underscored sheet shortcut", %{project: project} do
      sheet = sheet_fixture(project, %{name: "MC Jaime", shortcut: "mc.jaime"})

      block_fixture(sheet, %{
        type: "number",
        config: %{"label" => "Health"},
        value: %{"number" => 100}
      })

      meta = metadata(export_dialogic(project))
      assert Map.has_key?(meta["variable_folders"], "mc_jaime")
    end

    test "condition with 3 branches renders comment for extra branch", %{project: project} do
      sheet = sheet_fixture(project, %{name: "Mode"})

      block_fixture(sheet, %{
        type: "select",
        config: %{"label" => "Mood", "options" => ["happy", "sad", "angry"]},
        value: %{"select" => "happy"}
      })

      flow = flow_fixture(project, %{name: "Three Branch Flow"})
      flow = reload_flow(flow)
      entry = Enum.find(flow.nodes, &(&1.type == "entry"))

      condition =
        node_fixture(flow, %{
          type: "condition",
          data: %{
            "condition" =>
              Jason.encode!(%{
                "logic" => "all",
                "rules" => [
                  %{
                    "sheet" => sheet.shortcut,
                    "variable" => "mood",
                    "operator" => "equals",
                    "value" => "happy"
                  }
                ]
              }),
            "cases" => [
              %{"id" => "c0", "value" => "true", "label" => "True"},
              %{"id" => "c1", "value" => "false", "label" => "False"},
              %{"id" => "c2", "value" => "other", "label" => "Other"}
            ]
          }
        })

      d0 =
        node_fixture(flow, %{
          type: "dialogue",
          data: %{"text" => "Yay!", "speaker_sheet_id" => nil, "responses" => []}
        })

      d1 =
        node_fixture(flow, %{
          type: "dialogue",
          data: %{"text" => "Boo!", "speaker_sheet_id" => nil, "responses" => []}
        })

      d2 =
        node_fixture(flow, %{
          type: "dialogue",
          data: %{"text" => "Hmm.", "speaker_sheet_id" => nil, "responses" => []}
        })

      connection_fixture(flow, entry, condition)
      connection_fixture(flow, condition, d0, %{source_pin: "c0"})
      connection_fixture(flow, condition, d1, %{source_pin: "c1"})
      connection_fixture(flow, condition, d2, %{source_pin: "c2"})

      source = dtl_source(export_dialogic(project))
      assert has_line_matching?(source, ~r/^if .+:$/)
      assert has_line?(source, "else:")
      assert has_line?(source, "# (branch 2)")
    end

    test "dialogue with empty string text", %{project: project} do
      flow = flow_fixture(project, %{name: "Empty Text Flow"})
      flow = reload_flow(flow)
      entry = Enum.find(flow.nodes, &(&1.type == "entry"))

      dialogue =
        node_fixture(flow, %{
          type: "dialogue",
          data: %{
            "text" => "",
            "speaker_sheet_id" => nil,
            "responses" => []
          }
        })

      connection_fixture(flow, entry, dialogue)

      files = export_dialogic(project)
      source = dtl_source(files)
      assert source =~ "# Generated by Storyarn"
    end

    test "condition with unparseable expression falls back to if true:", %{project: project} do
      flow = flow_fixture(project, %{name: "Bad Cond Flow"})
      flow = reload_flow(flow)
      entry = Enum.find(flow.nodes, &(&1.type == "entry"))

      condition =
        node_fixture(flow, %{
          type: "condition",
          data: %{
            "condition" => "not valid json",
            "cases" => [
              %{"id" => "true", "value" => "true", "label" => "True"}
            ]
          }
        })

      connection_fixture(flow, entry, condition)

      source = dtl_source(export_dialogic(project))
      assert has_line?(source, "if true:")
    end
  end
end
