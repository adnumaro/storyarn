defmodule Storyarn.Exports.Serializers.InkTest do
  use Storyarn.DataCase, async: true

  alias Storyarn.Exports.{DataCollector, ExportOptions}
  alias Storyarn.Exports.Serializers.Ink

  alias Storyarn.Repo

  import Storyarn.AccountsFixtures
  import Storyarn.FlowsFixtures
  import Storyarn.ProjectsFixtures
  import Storyarn.SheetsFixtures

  # =============================================================================
  # Setup
  # =============================================================================

  defp reload_flow(flow), do: Repo.preload(flow, [:nodes, :connections], force: true)

  defp create_project(_context) do
    user = user_fixture()
    project = project_fixture(user)
    %{user: user, project: project}
  end

  defp default_opts do
    {:ok, opts} = ExportOptions.new(%{format: :ink, validate_before_export: false})
    opts
  end

  defp export_ink(project, opts \\ nil) do
    opts = opts || default_opts()
    project_data = DataCollector.collect(project.id, opts)
    {:ok, files} = Ink.serialize(project_data, opts)
    files
  end

  defp ink_source(files) do
    {_name, content} = Enum.find(files, fn {name, _} -> String.ends_with?(name, ".ink") end)
    content
  end

  defp metadata(files) do
    {_name, content} = Enum.find(files, fn {name, _} -> name == "metadata.json" end)
    Jason.decode!(content)
  end

  # =============================================================================
  # Behaviour callbacks
  # =============================================================================

  describe "behaviour callbacks" do
    test "content_type returns text/plain" do
      assert Ink.content_type() == "text/plain"
    end

    test "file_extension returns ink" do
      assert Ink.file_extension() == "ink"
    end

    test "format_label returns human-readable name" do
      assert Ink.format_label() == "Ink (.ink)"
    end

    test "supported_sections lists flows and sheets" do
      sections = Ink.supported_sections()
      assert :flows in sections
      assert :sheets in sections
    end

    test "serialize_to_file returns not_implemented" do
      assert {:error, :not_implemented} = Ink.serialize_to_file(nil, "", nil, [])
    end
  end

  # =============================================================================
  # Empty project
  # =============================================================================

  describe "empty project export" do
    setup [:create_project]

    test "produces ink file and metadata", %{project: project} do
      files = export_ink(project)
      assert length(files) == 2
      assert Enum.any?(files, fn {name, _} -> String.ends_with?(name, ".ink") end)
      assert Enum.any?(files, fn {name, _} -> name == "metadata.json" end)
    end

    test "ink file has header comment", %{project: project} do
      source = ink_source(export_ink(project))
      assert source =~ "// Generated by Storyarn"
    end

    test "metadata has required fields", %{project: project} do
      meta = metadata(export_ink(project))
      assert meta["storyarn_ink_metadata"] == "1.0.0"
      assert is_binary(meta["project"])
    end
  end

  # =============================================================================
  # Variable declarations
  # =============================================================================

  describe "variable declarations" do
    setup [:create_project]

    test "declares number variable", %{project: project} do
      sheet = sheet_fixture(project, %{name: "Hero"})

      block_fixture(sheet, %{
        type: "number",
        config: %{"label" => "Health"},
        value: %{"number" => 100}
      })

      _flow = flow_fixture(project, %{name: "Main"})

      source = ink_source(export_ink(project))
      assert source =~ "VAR "
      assert source =~ "= 100"
    end

    test "declares boolean variable", %{project: project} do
      sheet = sheet_fixture(project, %{name: "Flags"})

      block_fixture(sheet, %{
        type: "boolean",
        config: %{"label" => "Met Hero"},
        value: %{"boolean" => false}
      })

      _flow = flow_fixture(project, %{name: "Main"})

      source = ink_source(export_ink(project))
      assert source =~ "VAR "
      assert source =~ "= false"
    end

    test "declares string variable", %{project: project} do
      sheet = sheet_fixture(project, %{name: "Config"})

      block_fixture(sheet, %{
        type: "text",
        config: %{"label" => "Title"},
        value: %{"text" => "My Story"}
      })

      _flow = flow_fixture(project, %{name: "Main"})

      source = ink_source(export_ink(project))
      assert source =~ "VAR "
      assert source =~ ~s(= "My Story")
    end
  end

  # =============================================================================
  # Flow → Knot
  # =============================================================================

  describe "flow to knot conversion" do
    setup [:create_project]

    test "flow becomes a knot", %{project: project} do
      _flow = flow_fixture(project, %{name: "Tavern Intro"})
      source = ink_source(export_ink(project))
      assert source =~ "=== "
    end

    test "dialogue node has text", %{project: project} do
      flow = flow_fixture(project, %{name: "Test Flow"})
      flow = reload_flow(flow)
      entry = Enum.find(flow.nodes, &(&1.type == "entry"))

      dialogue =
        node_fixture(flow, %{
          type: "dialogue",
          data: %{
            "text" => "Hello adventurer!",
            "speaker_sheet_id" => nil,
            "responses" => []
          }
        })

      connection_fixture(flow, entry, dialogue)

      source = ink_source(export_ink(project))
      assert source =~ "Hello adventurer!"
    end

    test "dialogue with speaker includes speaker tag", %{project: project} do
      sheet = sheet_fixture(project, %{name: "Jaime"})
      flow = flow_fixture(project, %{name: "Test Flow"})
      flow = reload_flow(flow)
      entry = Enum.find(flow.nodes, &(&1.type == "entry"))

      dialogue =
        node_fixture(flow, %{
          type: "dialogue",
          data: %{
            "text" => "Hello!",
            "speaker_sheet_id" => sheet.id,
            "responses" => []
          }
        })

      connection_fixture(flow, entry, dialogue)

      source = ink_source(export_ink(project))
      assert source =~ "#speaker:"
    end

    test "dialogue responses become choices", %{project: project} do
      flow = flow_fixture(project, %{name: "Choice Flow"})
      flow = reload_flow(flow)
      entry = Enum.find(flow.nodes, &(&1.type == "entry"))

      dialogue =
        node_fixture(flow, %{
          type: "dialogue",
          data: %{
            "text" => "What do you want?",
            "speaker_sheet_id" => nil,
            "responses" => [
              %{"id" => "r1", "text" => "Fight", "condition" => nil, "instruction" => nil},
              %{"id" => "r2", "text" => "Run", "condition" => nil, "instruction" => nil}
            ]
          }
        })

      connection_fixture(flow, entry, dialogue)

      source = ink_source(export_ink(project))
      assert source =~ "+ [Fight]"
      assert source =~ "+ [Run]"
    end

    test "exit node produces END", %{project: project} do
      flow = flow_fixture(project, %{name: "Exit Flow"})
      flow = reload_flow(flow)
      entry = Enum.find(flow.nodes, &(&1.type == "entry"))
      exit_node = node_fixture(flow, %{type: "exit", data: %{}})
      connection_fixture(flow, entry, exit_node)

      source = ink_source(export_ink(project))
      assert source =~ "-> END"
    end
  end

  # =============================================================================
  # Condition nodes
  # =============================================================================

  describe "condition nodes" do
    setup [:create_project]

    test "condition produces if block", %{project: project} do
      sheet = sheet_fixture(project, %{name: "Hero"})

      block_fixture(sheet, %{
        type: "number",
        config: %{"label" => "Health"},
        value: %{"number" => 100}
      })

      flow = flow_fixture(project, %{name: "Cond Flow"})
      flow = reload_flow(flow)
      entry = Enum.find(flow.nodes, &(&1.type == "entry"))

      condition =
        node_fixture(flow, %{
          type: "condition",
          data: %{
            "condition" =>
              Jason.encode!(%{
                "logic" => "all",
                "rules" => [
                  %{
                    "sheet" => sheet.shortcut,
                    "variable" => "health",
                    "operator" => "greater_than",
                    "value" => "50"
                  }
                ]
              }),
            "cases" => [
              %{"id" => "true", "value" => "true", "label" => "True"},
              %{"id" => "false", "value" => "false", "label" => "False"}
            ]
          }
        })

      connection_fixture(flow, entry, condition)

      source = ink_source(export_ink(project))
      assert source =~ "{-"
    end

    test "condition with unsupported operator emits true fallback", %{project: project} do
      sheet = sheet_fixture(project, %{name: "Inventory"})

      block_fixture(sheet, %{
        type: "text",
        config: %{"label" => "Weapon"},
        value: %{"text" => "sword"}
      })

      flow = flow_fixture(project, %{name: "UnsupOp"})
      flow = reload_flow(flow)
      entry = Enum.find(flow.nodes, &(&1.type == "entry"))

      condition =
        node_fixture(flow, %{
          type: "condition",
          data: %{
            "condition" =>
              Jason.encode!(%{
                "logic" => "all",
                "rules" => [
                  %{
                    "sheet" => sheet.shortcut,
                    "variable" => "weapon",
                    "operator" => "contains",
                    "value" => "sw"
                  }
                ]
              }),
            "cases" => [
              %{"id" => "true", "value" => "true", "label" => "True"},
              %{"id" => "false", "value" => "false", "label" => "False"}
            ]
          }
        })

      connection_fixture(flow, entry, condition)

      source = ink_source(export_ink(project))
      assert source =~ "true /* unsupported: contains */"
    end
  end

  # =============================================================================
  # Instruction nodes
  # =============================================================================

  describe "instruction nodes" do
    setup [:create_project]

    test "instruction produces assignment", %{project: project} do
      sheet = sheet_fixture(project, %{name: "Flags"})

      block_fixture(sheet, %{
        type: "boolean",
        config: %{"label" => "Met"},
        value: %{"boolean" => false}
      })

      flow = flow_fixture(project, %{name: "Inst Flow"})
      flow = reload_flow(flow)
      entry = Enum.find(flow.nodes, &(&1.type == "entry"))

      instruction =
        node_fixture(flow, %{
          type: "instruction",
          data: %{
            "assignments" => [
              %{
                "sheet" => sheet.shortcut,
                "variable" => "met",
                "operator" => "set_true"
              }
            ]
          }
        })

      connection_fixture(flow, entry, instruction)

      source = ink_source(export_ink(project))
      # Ink uses ~ for instructions
      assert source =~ "~" or source =~ "="
    end
  end

  # =============================================================================
  # Hub and Jump
  # =============================================================================

  describe "hub and jump nodes" do
    setup [:create_project]
  end

  # =============================================================================
  # Metadata sidecar
  # =============================================================================

  describe "metadata sidecar" do
    setup [:create_project]

    test "includes characters from sheets", %{project: project} do
      sheet = sheet_fixture(project, %{name: "Jaime"})

      block_fixture(sheet, %{
        type: "number",
        config: %{"label" => "Health"},
        value: %{"number" => 100}
      })

      meta = metadata(export_ink(project))
      assert is_map(meta["characters"])
      char = meta["characters"][sheet.shortcut]
      assert char["name"] == "Jaime"
    end

    test "includes variable mapping", %{project: project} do
      sheet = sheet_fixture(project, %{name: "Hero"})

      block_fixture(sheet, %{
        type: "number",
        config: %{"label" => "Strength"},
        value: %{"number" => 50}
      })

      meta = metadata(export_ink(project))
      assert is_map(meta["variable_mapping"])
    end
  end

  # =============================================================================
  # Error paths
  # =============================================================================

  describe "error paths" do
    setup [:create_project]

    test "handles flow with no connected nodes gracefully", %{project: project} do
      # Flow with only auto-created entry node, nothing connected
      _flow = flow_fixture(project, %{name: "Lonely Flow"})
      source = ink_source(export_ink(project))
      # Should produce a knot but no content errors
      assert source =~ "=== "
      refute source =~ "** ("
    end

    test "handles dialogue node without speaker sheet", %{project: project} do
      flow = flow_fixture(project, %{name: "No Speaker"})
      flow = reload_flow(flow)
      entry = Enum.find(flow.nodes, &(&1.type == "entry"))

      dialogue =
        node_fixture(flow, %{
          type: "dialogue",
          data: %{
            "text" => "Hello!",
            "speaker_sheet_id" => nil,
            "responses" => []
          }
        })

      connection_fixture(flow, entry, dialogue)

      source = ink_source(export_ink(project))
      assert source =~ "Hello!"
      refute source =~ "#speaker:"
    end

    test "handles dialogue with empty text", %{project: project} do
      flow = flow_fixture(project, %{name: "Empty Text"})
      flow = reload_flow(flow)
      entry = Enum.find(flow.nodes, &(&1.type == "entry"))

      dialogue =
        node_fixture(flow, %{
          type: "dialogue",
          data: %{
            "text" => "",
            "speaker_sheet_id" => nil,
            "responses" => []
          }
        })

      connection_fixture(flow, entry, dialogue)

      source = ink_source(export_ink(project))
      assert source =~ "=== "
    end
  end

  # =============================================================================
  # Multi-flow
  # =============================================================================

  describe "multi-flow output" do
    setup [:create_project]

    test "multiple flows produce multiple knots", %{project: project} do
      _flow1 = flow_fixture(project, %{name: "Act 1"})
      _flow2 = flow_fixture(project, %{name: "Act 2"})

      source = ink_source(export_ink(project))
      # Should contain multiple knot declarations
      count = source |> String.split("===") |> length()
      assert count >= 3
    end
  end

  # =============================================================================
  # Scene node rendering
  # =============================================================================

  describe "scene nodes" do
    setup [:create_project]

    test "scene node renders location comment", %{project: project} do
      flow = flow_fixture(project, %{name: "Scene Flow"})
      flow = reload_flow(flow)
      entry = Enum.find(flow.nodes, &(&1.type == "entry"))

      scene =
        node_fixture(flow, %{
          type: "scene",
          data: %{"location" => "Tavern Interior"}
        })

      connection_fixture(flow, entry, scene)

      source = ink_source(export_ink(project))
      assert source =~ "# location:Tavern Interior"
    end

    test "scene node falls back to slug_line", %{project: project} do
      flow = flow_fixture(project, %{name: "Scene Slug Flow"})
      flow = reload_flow(flow)
      entry = Enum.find(flow.nodes, &(&1.type == "entry"))

      scene =
        node_fixture(flow, %{
          type: "scene",
          data: %{"slug_line" => "INT. CASTLE - NIGHT"}
        })

      connection_fixture(flow, entry, scene)

      source = ink_source(export_ink(project))
      assert source =~ "# location:INT. CASTLE - NIGHT"
    end

    test "scene node with empty data renders empty location", %{project: project} do
      flow = flow_fixture(project, %{name: "Empty Scene Flow"})
      flow = reload_flow(flow)
      entry = Enum.find(flow.nodes, &(&1.type == "entry"))

      scene = node_fixture(flow, %{type: "scene", data: %{}})
      connection_fixture(flow, entry, scene)

      source = ink_source(export_ink(project))
      assert source =~ "# location:"
    end
  end

  # =============================================================================
  # Subflow node rendering
  # =============================================================================

  describe "subflow nodes" do
    setup [:create_project]

    test "subflow renders tunnel divert", %{project: project} do
      flow = flow_fixture(project, %{name: "Subflow Flow"})
      flow = reload_flow(flow)
      entry = Enum.find(flow.nodes, &(&1.type == "entry"))

      subflow =
        node_fixture(flow, %{
          type: "subflow",
          data: %{"flow_shortcut" => "side_quest.rescue"}
        })

      connection_fixture(flow, entry, subflow)

      source = ink_source(export_ink(project))
      assert source =~ "-> side_quest_rescue ->"
    end

    test "subflow without shortcut uses fallback id", %{project: project} do
      flow = flow_fixture(project, %{name: "Subflow Fallback"})
      flow = reload_flow(flow)
      entry = Enum.find(flow.nodes, &(&1.type == "entry"))

      subflow = node_fixture(flow, %{type: "subflow", data: %{}})
      connection_fixture(flow, entry, subflow)

      source = ink_source(export_ink(project))
      assert source =~ "-> subflow_"
      assert source =~ " ->"
    end

    test "exit in tunnel flow emits ->-> not -> END", %{project: project} do
      target_flow = flow_fixture(project, %{name: "Side Quest"})
      target_flow = reload_flow(target_flow)
      target_entry = Enum.find(target_flow.nodes, &(&1.type == "entry"))
      target_exit = node_fixture(target_flow, %{type: "exit", data: %{}})
      connection_fixture(target_flow, target_entry, target_exit)

      caller_flow = flow_fixture(project, %{name: "Main"})
      caller_flow = reload_flow(caller_flow)
      caller_entry = Enum.find(caller_flow.nodes, &(&1.type == "entry"))

      subflow_node =
        node_fixture(caller_flow, %{
          type: "subflow",
          data: %{"flow_shortcut" => target_flow.shortcut}
        })

      after_dialogue =
        node_fixture(caller_flow, %{
          type: "dialogue",
          data: %{"text" => "Back!", "speaker_sheet_id" => nil, "responses" => []}
        })

      connection_fixture(caller_flow, caller_entry, subflow_node)
      connection_fixture(caller_flow, subflow_node, after_dialogue)

      source = ink_source(export_ink(project))
      assert source =~ "->->"
    end
  end

  # =============================================================================
  # Stage directions
  # =============================================================================

  describe "dialogue stage directions" do
    setup [:create_project]

    test "dialogue with stage directions renders comment before text", %{project: project} do
      flow = flow_fixture(project, %{name: "Stage Dir Flow"})
      flow = reload_flow(flow)
      entry = Enum.find(flow.nodes, &(&1.type == "entry"))

      dialogue =
        node_fixture(flow, %{
          type: "dialogue",
          data: %{
            "text" => "I feel so tired...",
            "stage_directions" => "Character slumps against the wall",
            "speaker_sheet_id" => nil,
            "responses" => []
          }
        })

      connection_fixture(flow, entry, dialogue)

      source = ink_source(export_ink(project))
      assert source =~ "// [Stage: Character slumps against the wall]"
      assert source =~ "I feel so tired..."
    end

    test "dialogue with HTML stage directions strips tags", %{project: project} do
      flow = flow_fixture(project, %{name: "HTML Stage Flow"})
      flow = reload_flow(flow)
      entry = Enum.find(flow.nodes, &(&1.type == "entry"))

      dialogue =
        node_fixture(flow, %{
          type: "dialogue",
          data: %{
            "text" => "Look out!",
            "stage_directions" => "<p>Runs <em>quickly</em></p>",
            "speaker_sheet_id" => nil,
            "responses" => []
          }
        })

      connection_fixture(flow, entry, dialogue)

      source = ink_source(export_ink(project))
      assert source =~ "// [Stage: Runs quickly]"
    end

    test "dialogue with empty stage directions does not render stage comment", %{project: project} do
      flow = flow_fixture(project, %{name: "No Stage Flow"})
      flow = reload_flow(flow)
      entry = Enum.find(flow.nodes, &(&1.type == "entry"))

      dialogue =
        node_fixture(flow, %{
          type: "dialogue",
          data: %{
            "text" => "Hello there",
            "stage_directions" => "",
            "speaker_sheet_id" => nil,
            "responses" => []
          }
        })

      connection_fixture(flow, entry, dialogue)

      source = ink_source(export_ink(project))
      assert source =~ "Hello there"
      refute source =~ "// [Stage:"
    end
  end

  # =============================================================================
  # Condition branching detail
  # =============================================================================

  describe "condition branching" do
    setup [:create_project]

    test "condition with true and false branches renders closing brace", %{project: project} do
      sheet = sheet_fixture(project, %{name: "Stats"})

      block_fixture(sheet, %{
        type: "boolean",
        config: %{"label" => "Alive"},
        value: %{"boolean" => true}
      })

      flow = flow_fixture(project, %{name: "Branch Flow"})
      flow = reload_flow(flow)
      entry = Enum.find(flow.nodes, &(&1.type == "entry"))

      condition =
        node_fixture(flow, %{
          type: "condition",
          data: %{
            "condition" =>
              Jason.encode!(%{
                "logic" => "all",
                "rules" => [
                  %{
                    "sheet" => sheet.shortcut,
                    "variable" => "alive",
                    "operator" => "is_true"
                  }
                ]
              }),
            "cases" => [
              %{"id" => "true", "value" => "true", "label" => "True"},
              %{"id" => "false", "value" => "false", "label" => "False"}
            ]
          }
        })

      true_dialogue =
        node_fixture(flow, %{
          type: "dialogue",
          data: %{"text" => "Still alive!", "speaker_sheet_id" => nil, "responses" => []}
        })

      false_dialogue =
        node_fixture(flow, %{
          type: "dialogue",
          data: %{"text" => "Dead...", "speaker_sheet_id" => nil, "responses" => []}
        })

      connection_fixture(flow, entry, condition)
      connection_fixture(flow, condition, true_dialogue, %{source_pin: "true"})
      connection_fixture(flow, condition, false_dialogue, %{source_pin: "false"})

      source = ink_source(export_ink(project))
      # Should have the if block and the else branch with closing brace
      assert source =~ "{-"
      assert source =~ "- else:"
      assert source =~ "}"
      assert source =~ "Still alive!"
      assert source =~ "Dead..."
    end

    test "condition with nil condition renders bare if", %{project: project} do
      flow = flow_fixture(project, %{name: "Nil Cond Flow"})
      flow = reload_flow(flow)
      entry = Enum.find(flow.nodes, &(&1.type == "entry"))

      condition =
        node_fixture(flow, %{
          type: "condition",
          data: %{
            "condition" => nil,
            "cases" => [
              %{"id" => "true", "value" => "true", "label" => "True"}
            ]
          }
        })

      connection_fixture(flow, entry, condition)

      source = ink_source(export_ink(project))
      assert source =~ "{-"
      assert source =~ "}"
    end

    test "condition with 3+ cases uses else and merged branch comment", %{project: project} do
      sheet = sheet_fixture(project, %{name: "World"})

      block_fixture(sheet, %{
        type: "number",
        config: %{"label" => "Weather"},
        value: %{"number" => 0}
      })

      flow = flow_fixture(project, %{name: "MultiCase"})
      flow = reload_flow(flow)
      entry = Enum.find(flow.nodes, &(&1.type == "entry"))

      condition =
        node_fixture(flow, %{
          type: "condition",
          data: %{
            "condition" =>
              Jason.encode!(%{
                "logic" => "all",
                "rules" => [
                  %{
                    "sheet" => sheet.shortcut,
                    "variable" => "weather",
                    "operator" => "equals",
                    "value" => "0"
                  }
                ]
              }),
            "cases" => [
              %{"id" => "sunny", "value" => "sunny", "label" => "Sunny"},
              %{"id" => "rainy", "value" => "rainy", "label" => "Rainy"},
              %{"id" => "stormy", "value" => "stormy", "label" => "Stormy"}
            ]
          }
        })

      connection_fixture(flow, entry, condition)

      source = ink_source(export_ink(project))
      assert source =~ "- else:"
      assert source =~ "// (merged branch:"
    end
  end

  # =============================================================================
  # Jump nodes with hub targets
  # =============================================================================

  describe "jump nodes" do
    setup [:create_project]

    test "jump to hub renders divert to hub label", %{project: project} do
      flow = flow_fixture(project, %{name: "Jump Hub Flow"})
      flow = reload_flow(flow)
      entry = Enum.find(flow.nodes, &(&1.type == "entry"))

      hub =
        node_fixture(flow, %{
          type: "hub",
          data: %{"label" => "meeting_point"}
        })

      jump =
        node_fixture(flow, %{
          type: "jump",
          data: %{"hub_id" => hub.id}
        })

      connection_fixture(flow, entry, jump)

      # Also add dialogue after hub so hub section has content
      dialogue =
        node_fixture(flow, %{
          type: "dialogue",
          data: %{"text" => "We meet again!", "speaker_sheet_id" => nil, "responses" => []}
        })

      connection_fixture(flow, hub, dialogue)

      source = ink_source(export_ink(project))
      assert source =~ "-> meeting_point"
    end

    test "jump to external flow renders divert", %{project: project} do
      flow = flow_fixture(project, %{name: "Jump Ext Flow"})
      flow = reload_flow(flow)
      entry = Enum.find(flow.nodes, &(&1.type == "entry"))

      jump =
        node_fixture(flow, %{
          type: "jump",
          data: %{"target_flow_shortcut" => "act2.beginning"}
        })

      connection_fixture(flow, entry, jump)

      source = ink_source(export_ink(project))
      assert source =~ "-> act2_beginning"
    end
  end

  # =============================================================================
  # Instruction with empty/no assignments
  # =============================================================================

  describe "instruction edge cases" do
    setup [:create_project]

    test "instruction with empty assignments produces no output", %{project: project} do
      flow = flow_fixture(project, %{name: "Empty Inst Flow"})
      flow = reload_flow(flow)
      entry = Enum.find(flow.nodes, &(&1.type == "entry"))

      instruction =
        node_fixture(flow, %{
          type: "instruction",
          data: %{"assignments" => []}
        })

      exit_node = node_fixture(flow, %{type: "exit", data: %{}})

      connection_fixture(flow, entry, instruction)
      connection_fixture(flow, instruction, exit_node)

      source = ink_source(export_ink(project))
      # Should still produce valid output with no instruction lines
      assert source =~ "-> END"
    end

    test "instruction with nil data produces no output", %{project: project} do
      flow = flow_fixture(project, %{name: "Nil Inst Flow"})
      flow = reload_flow(flow)
      entry = Enum.find(flow.nodes, &(&1.type == "entry"))

      instruction = node_fixture(flow, %{type: "instruction", data: %{}})
      exit_node = node_fixture(flow, %{type: "exit", data: %{}})

      connection_fixture(flow, entry, instruction)
      connection_fixture(flow, instruction, exit_node)

      source = ink_source(export_ink(project))
      assert source =~ "-> END"
    end
  end

  # =============================================================================
  # Variable declaration edge cases
  # =============================================================================

  describe "variable declaration edge cases" do
    setup [:create_project]

    test "constant blocks are excluded from variable declarations", %{project: project} do
      sheet = sheet_fixture(project, %{name: "Constants"})

      block_fixture(sheet, %{
        type: "number",
        config: %{"label" => "Max HP"},
        value: %{"number" => 999},
        is_constant: true
      })

      _flow = flow_fixture(project, %{name: "Main"})

      source = ink_source(export_ink(project))
      refute source =~ "VAR "
      refute source =~ "max_hp"
    end

    test "select variable is declared as string", %{project: project} do
      sheet = sheet_fixture(project, %{name: "Char"})

      block_fixture(sheet, %{
        type: "select",
        config: %{
          "label" => "Class",
          "options" => [
            %{"value" => "warrior", "label" => "Warrior"},
            %{"value" => "mage", "label" => "Mage"}
          ]
        },
        value: %{"select" => "warrior"}
      })

      _flow = flow_fixture(project, %{name: "Main"})

      source = ink_source(export_ink(project))
      assert source =~ "VAR "
      assert source =~ ~s("warrior")
    end

    test "empty project with no variables produces no VAR section", %{project: project} do
      _flow = flow_fixture(project, %{name: "Main"})
      source = ink_source(export_ink(project))
      refute source =~ "// === Variables ==="
    end
  end

  # =============================================================================
  # Metadata sidecar detail
  # =============================================================================

  describe "metadata sidecar detail" do
    setup [:create_project]

    test "metadata properties exclude constants", %{project: project} do
      sheet = sheet_fixture(project, %{name: "Hero"})

      block_fixture(sheet, %{
        type: "number",
        config: %{"label" => "Health"},
        value: %{"number" => 100}
      })

      block_fixture(sheet, %{
        type: "text",
        config: %{"label" => "Title"},
        value: %{"text" => "Sir"},
        is_constant: true
      })

      meta = metadata(export_ink(project))
      char = meta["characters"][sheet.shortcut]
      props = char["properties"]
      # Health should be in properties, but Title (constant) should NOT
      assert Map.has_key?(props, "health")
      refute Map.has_key?(props, "title")
    end

    test "metadata variable mapping uses identifier format", %{project: project} do
      sheet = sheet_fixture(project, %{name: "mc.jaime"})

      block_fixture(sheet, %{
        type: "number",
        config: %{"label" => "Strength"},
        value: %{"number" => 10}
      })

      meta = metadata(export_ink(project))
      mapping = meta["variable_mapping"]
      # Should map dot-separated refs to underscore identifiers
      ref_key = Enum.find(Map.keys(mapping), &String.contains?(&1, "."))

      if ref_key do
        assert mapping[ref_key] =~ ~r/^[a-z0-9_]+$/
      end
    end

    test "metadata includes project name", %{project: project} do
      meta = metadata(export_ink(project))
      assert meta["project"] == project.name
    end
  end

  # =============================================================================
  # Dialogue with HTML text
  # =============================================================================

  describe "dialogue HTML stripping" do
    setup [:create_project]

    test "strips HTML tags from dialogue text", %{project: project} do
      flow = flow_fixture(project, %{name: "HTML Flow"})
      flow = reload_flow(flow)
      entry = Enum.find(flow.nodes, &(&1.type == "entry"))

      dialogue =
        node_fixture(flow, %{
          type: "dialogue",
          data: %{
            "text" => "<p>Hello <em>world</em>!</p>",
            "speaker_sheet_id" => nil,
            "responses" => []
          }
        })

      connection_fixture(flow, entry, dialogue)

      source = ink_source(export_ink(project))
      assert source =~ "Hello world!"
      refute source =~ "<p>"
      refute source =~ "<em>"
    end
  end

  # =============================================================================
  # Flow naming
  # =============================================================================

  describe "flow naming" do
    setup [:create_project]

    test "flow with digit-starting name gets _ prefix in knot", %{project: project} do
      _flow = flow_fixture(project, %{name: "1st Quest"})
      source = ink_source(export_ink(project))
      assert source =~ "=== _1"
    end

    test "flow comment includes flow name", %{project: project} do
      _flow = flow_fixture(project, %{name: "Tavern Scene"})

      source = ink_source(export_ink(project))
      assert source =~ "// === Flow: Tavern Scene ==="
    end
  end

  # =============================================================================
  # Complex multi-node flow
  # =============================================================================

  describe "complex flow chains" do
    setup [:create_project]

    test "entry -> dialogue -> instruction -> exit chain", %{project: project} do
      sheet = sheet_fixture(project, %{name: "Flags"})

      block_fixture(sheet, %{
        type: "boolean",
        config: %{"label" => "Visited"},
        value: %{"boolean" => false}
      })

      flow = flow_fixture(project, %{name: "Chain Flow"})
      flow = reload_flow(flow)
      entry = Enum.find(flow.nodes, &(&1.type == "entry"))

      dialogue =
        node_fixture(flow, %{
          type: "dialogue",
          data: %{"text" => "Welcome!", "speaker_sheet_id" => nil, "responses" => []}
        })

      instruction =
        node_fixture(flow, %{
          type: "instruction",
          data: %{
            "assignments" => [
              %{"sheet" => sheet.shortcut, "variable" => "visited", "operator" => "set_true"}
            ]
          }
        })

      exit_node = node_fixture(flow, %{type: "exit", data: %{}})

      connection_fixture(flow, entry, dialogue)
      connection_fixture(flow, dialogue, instruction)
      connection_fixture(flow, instruction, exit_node)

      source = ink_source(export_ink(project))
      assert source =~ "Welcome!"
      assert source =~ "-> END"
    end

    test "entry -> scene -> dialogue -> exit chain", %{project: project} do
      flow = flow_fixture(project, %{name: "Scene Chain Flow"})
      flow = reload_flow(flow)
      entry = Enum.find(flow.nodes, &(&1.type == "entry"))

      scene =
        node_fixture(flow, %{
          type: "scene",
          data: %{"location" => "Dark Forest"}
        })

      dialogue =
        node_fixture(flow, %{
          type: "dialogue",
          data: %{"text" => "The forest is dark.", "speaker_sheet_id" => nil, "responses" => []}
        })

      exit_node = node_fixture(flow, %{type: "exit", data: %{}})

      connection_fixture(flow, entry, scene)
      connection_fixture(flow, scene, dialogue)
      connection_fixture(flow, dialogue, exit_node)

      source = ink_source(export_ink(project))
      assert source =~ "# location:Dark Forest"
      assert source =~ "The forest is dark."
      assert source =~ "-> END"
    end

    test "dialogue with conditional choices renders condition guard", %{project: project} do
      sheet = sheet_fixture(project, %{name: "Hero"})

      block_fixture(sheet, %{
        type: "number",
        config: %{"label" => "Gold"},
        value: %{"number" => 100}
      })

      flow = flow_fixture(project, %{name: "Cond Choice Flow"})
      flow = reload_flow(flow)
      entry = Enum.find(flow.nodes, &(&1.type == "entry"))

      dialogue =
        node_fixture(flow, %{
          type: "dialogue",
          data: %{
            "text" => "What will you buy?",
            "speaker_sheet_id" => nil,
            "responses" => [
              %{
                "id" => "r1",
                "text" => "Buy sword",
                "condition" =>
                  Jason.encode!(%{
                    "logic" => "all",
                    "rules" => [
                      %{
                        "sheet" => sheet.shortcut,
                        "variable" => "gold",
                        "operator" => "greater_than",
                        "value" => "50"
                      }
                    ]
                  }),
                "instruction" => nil
              },
              %{"id" => "r2", "text" => "Leave", "condition" => nil, "instruction" => nil}
            ]
          }
        })

      connection_fixture(flow, entry, dialogue)

      source = ink_source(export_ink(project))
      assert source =~ "What will you buy?"
      # Choice with condition should have {condition} prefix before [text]
      assert source =~ "[Buy sword]"
      assert source =~ "+ [Leave]"
    end

    test "dialogue with response instruction assignments", %{project: project} do
      sheet = sheet_fixture(project, %{name: "Flags"})

      block_fixture(sheet, %{
        type: "boolean",
        config: %{"label" => "Bought"},
        value: %{"boolean" => false}
      })

      flow = flow_fixture(project, %{name: "Resp Inst Flow"})
      flow = reload_flow(flow)
      entry = Enum.find(flow.nodes, &(&1.type == "entry"))

      dialogue =
        node_fixture(flow, %{
          type: "dialogue",
          data: %{
            "text" => "Want to buy?",
            "speaker_sheet_id" => nil,
            "responses" => [
              %{
                "id" => "r1",
                "text" => "Yes",
                "condition" => nil,
                "instruction" =>
                  Jason.encode!([
                    %{
                      "sheet" => sheet.shortcut,
                      "variable" => "bought",
                      "operator" => "set_true"
                    }
                  ])
              },
              %{"id" => "r2", "text" => "No", "condition" => nil, "instruction" => nil}
            ]
          }
        })

      connection_fixture(flow, entry, dialogue)

      source = ink_source(export_ink(project))
      assert source =~ "Want to buy?"
      assert source =~ "+ [Yes]"
      assert source =~ "+ [No]"
      # Verify the assignment instruction renders inside choice body
      assert source =~ "~ "
    end

    test "response with both condition and instruction renders guard and assignment", %{
      project: project
    } do
      sheet = sheet_fixture(project, %{name: "Hero"})

      block_fixture(sheet, %{
        type: "number",
        config: %{"label" => "Gold"},
        value: %{"number" => 100}
      })

      block_fixture(sheet, %{
        type: "boolean",
        config: %{"label" => "Bought"},
        value: %{"boolean" => false}
      })

      flow = flow_fixture(project, %{name: "Both Flow"})
      flow = reload_flow(flow)
      entry = Enum.find(flow.nodes, &(&1.type == "entry"))

      dialogue =
        node_fixture(flow, %{
          type: "dialogue",
          data: %{
            "text" => "Shop?",
            "speaker_sheet_id" => nil,
            "responses" => [
              %{
                "id" => "r1",
                "text" => "Buy",
                "condition" =>
                  Jason.encode!(%{
                    "logic" => "all",
                    "rules" => [
                      %{
                        "sheet" => sheet.shortcut,
                        "variable" => "gold",
                        "operator" => "greater_than",
                        "value" => "50"
                      }
                    ]
                  }),
                "instruction" =>
                  Jason.encode!([
                    %{
                      "sheet" => sheet.shortcut,
                      "variable" => "bought",
                      "operator" => "set_true"
                    }
                  ])
              },
              %{"id" => "r2", "text" => "Leave", "condition" => nil, "instruction" => nil}
            ]
          }
        })

      connection_fixture(flow, entry, dialogue)

      source = ink_source(export_ink(project))
      assert source =~ "[Buy]"
      assert source =~ "~ "
      assert source =~ "+ [Leave]"
    end

    test "hub with connected dialogue produces stitch section", %{project: project} do
      flow = flow_fixture(project, %{name: "Hub Section Flow"})
      flow = reload_flow(flow)
      entry = Enum.find(flow.nodes, &(&1.type == "entry"))

      hub =
        node_fixture(flow, %{
          type: "hub",
          data: %{"label" => "rest_area"}
        })

      dialogue_after_hub =
        node_fixture(flow, %{
          type: "dialogue",
          data: %{
            "text" => "You rest here.",
            "speaker_sheet_id" => nil,
            "responses" => []
          }
        })

      exit_after_hub = node_fixture(flow, %{type: "exit", data: %{}})

      # Entry -> Hub (creates a divert)
      connection_fixture(flow, entry, hub)
      # Hub -> Dialogue (hub section body)
      connection_fixture(flow, hub, dialogue_after_hub)
      connection_fixture(flow, dialogue_after_hub, exit_after_hub)

      source = ink_source(export_ink(project))
      # Should have a stitch (= label)
      assert source =~ "= rest_area"
      # And the hub section dialogue
      assert source =~ "You rest here."
      # And the divert to the hub
      assert source =~ "-> rest_area"
      assert source =~ "-> END"
    end
  end

  # =============================================================================
  # Special character escaping (B1/B2/B6)
  # =============================================================================

  describe "special character escaping" do
    setup [:create_project]

    test "dialogue text with square brackets escapes them", %{project: project} do
      flow = flow_fixture(project, %{name: "Bracket Flow"})
      flow = reload_flow(flow)
      entry = Enum.find(flow.nodes, &(&1.type == "entry"))

      dialogue =
        node_fixture(flow, %{
          type: "dialogue",
          data: %{
            "text" => "Check [inventory] now",
            "speaker_sheet_id" => nil,
            "responses" => []
          }
        })

      connection_fixture(flow, entry, dialogue)

      source = ink_source(export_ink(project))
      # Square brackets must be escaped to avoid Ink treating them as choice markers
      refute source =~ "Check [inventory] now"
      assert source =~ ~S(Check \[inventory\] now)
    end

    test "response text with square brackets escapes them", %{project: project} do
      flow = flow_fixture(project, %{name: "Bracket Choice"})
      flow = reload_flow(flow)
      entry = Enum.find(flow.nodes, &(&1.type == "entry"))

      dialogue =
        node_fixture(flow, %{
          type: "dialogue",
          data: %{
            "text" => "What do?",
            "speaker_sheet_id" => nil,
            "responses" => [
              %{"id" => "r1", "text" => "Take [item]", "condition" => nil, "instruction" => nil}
            ]
          }
        })

      connection_fixture(flow, entry, dialogue)

      source = ink_source(export_ink(project))
      # Brackets in response text must be escaped inside the [choice] wrapper
      refute source =~ "[Take [item]]"
    end

    test "dialogue text with divert arrow is safe in context", %{project: project} do
      flow = flow_fixture(project, %{name: "Arrow Flow"})
      flow = reload_flow(flow)
      entry = Enum.find(flow.nodes, &(&1.type == "entry"))

      dialogue =
        node_fixture(flow, %{
          type: "dialogue",
          data: %{
            "text" => "Go -> forward",
            "speaker_sheet_id" => nil,
            "responses" => []
          }
        })

      connection_fixture(flow, entry, dialogue)

      source = ink_source(export_ink(project))
      # The text "Go -> forward" is on the same line as dialogue, not at line start,
      # so it won't be parsed as a divert. Verify the text appears.
      assert source =~ "Go -> forward"
    end
  end

  # =============================================================================
  # Empty/invalid condition (B3)
  # =============================================================================

  describe "empty condition edge cases" do
    setup [:create_project]

    test "condition with empty/unparseable expression skips condition block", %{
      project: project
    } do
      flow = flow_fixture(project, %{name: "Empty Cond"})
      flow = reload_flow(flow)
      entry = Enum.find(flow.nodes, &(&1.type == "entry"))

      condition =
        node_fixture(flow, %{
          type: "condition",
          data: %{
            "condition" => "not valid json",
            "cases" => [%{"id" => "true", "value" => "true", "label" => "True"}]
          }
        })

      dialogue =
        node_fixture(flow, %{
          type: "dialogue",
          data: %{"text" => "Fallthrough", "speaker_sheet_id" => nil, "responses" => []}
        })

      connection_fixture(flow, entry, condition)
      connection_fixture(flow, condition, dialogue, %{source_pin: "true"})

      source = ink_source(export_ink(project))
      # A bare {- without expression is invalid Ink — should use {- true:
      refute source =~ ~r/\{-\s*\n/
    end
  end

  # =============================================================================
  # Speaker shortcut dots (B4)
  # =============================================================================

  describe "speaker shortcut identifier conversion" do
    setup [:create_project]

    test "speaker shortcut with dots is converted to identifier", %{project: project} do
      sheet = sheet_fixture(project, %{name: "MC Jaime", shortcut: "mc.jaime"})
      flow = flow_fixture(project, %{name: "Speaker Dot"})
      flow = reload_flow(flow)
      entry = Enum.find(flow.nodes, &(&1.type == "entry"))

      dialogue =
        node_fixture(flow, %{
          type: "dialogue",
          data: %{"text" => "Hello!", "speaker_sheet_id" => sheet.id, "responses" => []}
        })

      connection_fixture(flow, entry, dialogue)

      source = ink_source(export_ink(project))
      # Dots in shortcut should be converted to underscores
      refute source =~ "#speaker:mc.jaime"
      assert source =~ "#speaker:mc_jaime"
    end
  end

  # =============================================================================
  # String variable newline escaping (B5)
  # =============================================================================

  describe "string variable newline escaping" do
    setup [:create_project]

    test "string variable with newline escapes it in declaration", %{project: project} do
      sheet = sheet_fixture(project, %{name: "Config"})

      block_fixture(sheet, %{
        type: "text",
        config: %{"label" => "Greeting"},
        value: %{"text" => "Hello\nWorld"}
      })

      _flow = flow_fixture(project, %{name: "Main"})

      source = ink_source(export_ink(project))
      # Newlines must be escaped in VAR string values (multi-line VAR is invalid Ink)
      refute source =~ "\"Hello\nWorld\""
    end
  end
end
