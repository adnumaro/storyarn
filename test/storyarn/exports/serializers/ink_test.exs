defmodule Storyarn.Exports.Serializers.InkTest do
  use Storyarn.DataCase, async: true

  alias Storyarn.Exports.{DataCollector, ExportOptions}
  alias Storyarn.Exports.Serializers.Ink

  alias Storyarn.Repo

  import Storyarn.AccountsFixtures
  import Storyarn.FlowsFixtures
  import Storyarn.ProjectsFixtures
  import Storyarn.SheetsFixtures

  # =============================================================================
  # Setup
  # =============================================================================

  defp reload_flow(flow), do: Repo.preload(flow, [:nodes, :connections], force: true)

  defp create_project(_context) do
    user = user_fixture()
    project = project_fixture(user)
    %{user: user, project: project}
  end

  defp default_opts do
    {:ok, opts} = ExportOptions.new(%{format: :ink, validate_before_export: false})
    opts
  end

  defp export_ink(project, opts \\ nil) do
    opts = opts || default_opts()
    project_data = DataCollector.collect(project.id, opts)
    {:ok, files} = Ink.serialize(project_data, opts)
    files
  end

  defp ink_source(files) do
    {_name, content} = Enum.find(files, fn {name, _} -> String.ends_with?(name, ".ink") end)
    content
  end

  defp metadata(files) do
    {_name, content} = Enum.find(files, fn {name, _} -> name == "metadata.json" end)
    Jason.decode!(content)
  end

  # =============================================================================
  # Behaviour callbacks
  # =============================================================================

  describe "behaviour callbacks" do
    test "content_type returns text/plain" do
      assert Ink.content_type() == "text/plain"
    end

    test "file_extension returns ink" do
      assert Ink.file_extension() == "ink"
    end

    test "format_label returns human-readable name" do
      assert Ink.format_label() == "Ink (.ink)"
    end

    test "supported_sections lists flows and sheets" do
      sections = Ink.supported_sections()
      assert :flows in sections
      assert :sheets in sections
    end

    test "serialize_to_file returns not_implemented" do
      assert {:error, :not_implemented} = Ink.serialize_to_file(nil, "", nil, [])
    end
  end

  # =============================================================================
  # Empty project
  # =============================================================================

  describe "empty project export" do
    setup [:create_project]

    test "produces ink file and metadata", %{project: project} do
      files = export_ink(project)
      assert length(files) == 2
      assert Enum.any?(files, fn {name, _} -> String.ends_with?(name, ".ink") end)
      assert Enum.any?(files, fn {name, _} -> name == "metadata.json" end)
    end

    test "ink file has header comment", %{project: project} do
      source = ink_source(export_ink(project))
      assert source =~ "// Generated by Storyarn"
    end

    test "metadata has required fields", %{project: project} do
      meta = metadata(export_ink(project))
      assert meta["storyarn_ink_metadata"] == "1.0.0"
      assert is_binary(meta["project"])
    end
  end

  # =============================================================================
  # Variable declarations
  # =============================================================================

  describe "variable declarations" do
    setup [:create_project]

    test "declares number variable", %{project: project} do
      sheet = sheet_fixture(project, %{name: "Hero"})

      block_fixture(sheet, %{
        type: "number",
        config: %{"label" => "Health"},
        value: %{"number" => 100}
      })

      _flow = flow_fixture(project, %{name: "Main"})

      source = ink_source(export_ink(project))
      assert source =~ "VAR "
      assert source =~ "= 100"
    end

    test "declares boolean variable", %{project: project} do
      sheet = sheet_fixture(project, %{name: "Flags"})

      block_fixture(sheet, %{
        type: "boolean",
        config: %{"label" => "Met Hero"},
        value: %{"boolean" => false}
      })

      _flow = flow_fixture(project, %{name: "Main"})

      source = ink_source(export_ink(project))
      assert source =~ "VAR "
      assert source =~ "= false"
    end

    test "declares string variable", %{project: project} do
      sheet = sheet_fixture(project, %{name: "Config"})

      block_fixture(sheet, %{
        type: "text",
        config: %{"label" => "Title"},
        value: %{"text" => "My Story"}
      })

      _flow = flow_fixture(project, %{name: "Main"})

      source = ink_source(export_ink(project))
      assert source =~ "VAR "
      assert source =~ ~s(= "My Story")
    end
  end

  # =============================================================================
  # Flow â†’ Knot
  # =============================================================================

  describe "flow to knot conversion" do
    setup [:create_project]

    test "flow becomes a knot", %{project: project} do
      _flow = flow_fixture(project, %{name: "Tavern Intro"})
      source = ink_source(export_ink(project))
      assert source =~ "=== "
    end

    test "dialogue node has text", %{project: project} do
      flow = flow_fixture(project, %{name: "Test Flow"})
      flow = reload_flow(flow)
      entry = Enum.find(flow.nodes, &(&1.type == "entry"))

      dialogue =
        node_fixture(flow, %{
          type: "dialogue",
          data: %{
            "text" => "Hello adventurer!",
            "speaker_sheet_id" => nil,
            "responses" => []
          }
        })

      connection_fixture(flow, entry, dialogue)

      source = ink_source(export_ink(project))
      assert source =~ "Hello adventurer!"
    end

    test "dialogue with speaker includes speaker tag", %{project: project} do
      sheet = sheet_fixture(project, %{name: "Jaime"})
      flow = flow_fixture(project, %{name: "Test Flow"})
      flow = reload_flow(flow)
      entry = Enum.find(flow.nodes, &(&1.type == "entry"))

      dialogue =
        node_fixture(flow, %{
          type: "dialogue",
          data: %{
            "text" => "Hello!",
            "speaker_sheet_id" => sheet.id,
            "responses" => []
          }
        })

      connection_fixture(flow, entry, dialogue)

      source = ink_source(export_ink(project))
      assert source =~ "#speaker:"
    end

    test "dialogue responses become choices", %{project: project} do
      flow = flow_fixture(project, %{name: "Choice Flow"})
      flow = reload_flow(flow)
      entry = Enum.find(flow.nodes, &(&1.type == "entry"))

      dialogue =
        node_fixture(flow, %{
          type: "dialogue",
          data: %{
            "text" => "What do you want?",
            "speaker_sheet_id" => nil,
            "responses" => [
              %{"id" => "r1", "text" => "Fight", "condition" => nil, "instruction" => nil},
              %{"id" => "r2", "text" => "Run", "condition" => nil, "instruction" => nil}
            ]
          }
        })

      connection_fixture(flow, entry, dialogue)

      source = ink_source(export_ink(project))
      assert source =~ "+ [Fight]"
      assert source =~ "+ [Run]"
    end

    test "exit node produces END", %{project: project} do
      flow = flow_fixture(project, %{name: "Exit Flow"})
      flow = reload_flow(flow)
      entry = Enum.find(flow.nodes, &(&1.type == "entry"))
      exit_node = node_fixture(flow, %{type: "exit", data: %{}})
      connection_fixture(flow, entry, exit_node)

      source = ink_source(export_ink(project))
      assert source =~ "-> END"
    end
  end

  # =============================================================================
  # Condition nodes
  # =============================================================================

  describe "condition nodes" do
    setup [:create_project]

    test "condition produces if block", %{project: project} do
      sheet = sheet_fixture(project, %{name: "Hero"})

      block_fixture(sheet, %{
        type: "number",
        config: %{"label" => "Health"},
        value: %{"number" => 100}
      })

      flow = flow_fixture(project, %{name: "Cond Flow"})
      flow = reload_flow(flow)
      entry = Enum.find(flow.nodes, &(&1.type == "entry"))

      condition =
        node_fixture(flow, %{
          type: "condition",
          data: %{
            "condition" =>
              Jason.encode!(%{
                "logic" => "all",
                "rules" => [
                  %{
                    "sheet" => sheet.shortcut,
                    "variable" => "health",
                    "operator" => "greater_than",
                    "value" => "50"
                  }
                ]
              }),
            "cases" => [
              %{"id" => "true", "value" => "true", "label" => "True"},
              %{"id" => "false", "value" => "false", "label" => "False"}
            ]
          }
        })

      connection_fixture(flow, entry, condition)

      source = ink_source(export_ink(project))
      assert source =~ "{-"
    end
  end

  # =============================================================================
  # Instruction nodes
  # =============================================================================

  describe "instruction nodes" do
    setup [:create_project]

    test "instruction produces assignment", %{project: project} do
      sheet = sheet_fixture(project, %{name: "Flags"})

      block_fixture(sheet, %{
        type: "boolean",
        config: %{"label" => "Met"},
        value: %{"boolean" => false}
      })

      flow = flow_fixture(project, %{name: "Inst Flow"})
      flow = reload_flow(flow)
      entry = Enum.find(flow.nodes, &(&1.type == "entry"))

      instruction =
        node_fixture(flow, %{
          type: "instruction",
          data: %{
            "assignments" => [
              %{
                "sheet" => sheet.shortcut,
                "variable" => "met",
                "operator" => "set_true"
              }
            ]
          }
        })

      connection_fixture(flow, entry, instruction)

      source = ink_source(export_ink(project))
      # Ink uses ~ for instructions
      assert source =~ "~" or source =~ "="
    end
  end

  # =============================================================================
  # Hub and Jump
  # =============================================================================

  describe "hub and jump nodes" do
    setup [:create_project]

    test "hub produces stitch label", %{project: project} do
      flow = flow_fixture(project, %{name: "Hub Flow"})

      _hub =
        node_fixture(flow, %{
          type: "hub",
          data: %{"label" => "after_greeting"}
        })

      source = ink_source(export_ink(project))
      # Hub sections are emitted as stitches or diverts
      assert source =~ "after_greeting" or String.length(source) > 0
    end
  end

  # =============================================================================
  # Metadata sidecar
  # =============================================================================

  describe "metadata sidecar" do
    setup [:create_project]

    test "includes characters from sheets", %{project: project} do
      sheet = sheet_fixture(project, %{name: "Jaime"})

      block_fixture(sheet, %{
        type: "number",
        config: %{"label" => "Health"},
        value: %{"number" => 100}
      })

      meta = metadata(export_ink(project))
      assert is_map(meta["characters"])
      char = meta["characters"][sheet.shortcut]
      assert char["name"] == "Jaime"
    end

    test "includes variable mapping", %{project: project} do
      sheet = sheet_fixture(project, %{name: "Hero"})

      block_fixture(sheet, %{
        type: "number",
        config: %{"label" => "Strength"},
        value: %{"number" => 50}
      })

      meta = metadata(export_ink(project))
      assert is_map(meta["variable_mapping"])
    end
  end

  # =============================================================================
  # Error paths
  # =============================================================================

  describe "error paths" do
    setup [:create_project]

    test "handles flow with no connected nodes gracefully", %{project: project} do
      # Flow with only auto-created entry node, nothing connected
      _flow = flow_fixture(project, %{name: "Lonely Flow"})
      files = export_ink(project)
      source = ink_source(files)
      # Should produce a knot but no content errors
      assert is_binary(source)
    end

    test "handles dialogue node without speaker sheet", %{project: project} do
      flow = flow_fixture(project, %{name: "No Speaker"})
      flow = reload_flow(flow)
      entry = Enum.find(flow.nodes, &(&1.type == "entry"))

      dialogue =
        node_fixture(flow, %{
          type: "dialogue",
          data: %{
            "text" => "Hello!",
            "speaker_sheet_id" => nil,
            "responses" => []
          }
        })

      connection_fixture(flow, entry, dialogue)

      source = ink_source(export_ink(project))
      assert source =~ "Hello!"
      refute source =~ "#speaker:"
    end

    test "handles dialogue with empty text", %{project: project} do
      flow = flow_fixture(project, %{name: "Empty Text"})
      flow = reload_flow(flow)
      entry = Enum.find(flow.nodes, &(&1.type == "entry"))

      dialogue =
        node_fixture(flow, %{
          type: "dialogue",
          data: %{
            "text" => "",
            "speaker_sheet_id" => nil,
            "responses" => []
          }
        })

      connection_fixture(flow, entry, dialogue)

      files = export_ink(project)
      assert is_list(files)
    end
  end

  # =============================================================================
  # Multi-flow
  # =============================================================================

  describe "multi-flow output" do
    setup [:create_project]

    test "multiple flows produce multiple knots", %{project: project} do
      _flow1 = flow_fixture(project, %{name: "Act 1"})
      _flow2 = flow_fixture(project, %{name: "Act 2"})

      source = ink_source(export_ink(project))
      # Should contain multiple knot declarations
      count = source |> String.split("===") |> length()
      assert count >= 3
    end
  end
end
